{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/superPropBase.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../../src/base/webgl/Sprite2dRenderer.ts","../../src/base/AbstractProjection.ts","../../src/base/LinearProjection.ts","../../src/base/webgl/UniformBatchRenderer.ts","../../src/base/index.ts","../../src/proj2d/Matrix2d.ts","../../src/proj2d/tiling/TilingSprite2dRenderer.ts","../../src/proj2d/Projection2d.ts","../../src/utils.ts","../../src/proj2d/Container2d.ts","../../src/proj2d/mesh/Mesh2d.ts","../../src/proj2d/sprites/Sprite2d.ts","../../src/proj2d/tiling/TilingSprite2d.ts","../../src/proj2d/sprites/convert.ts","../../src/proj2d/sprites/Text2d.ts","../../src/proj2d/z_masks/SpriteMaskFilter.ts","../../src/proj2d/z_masks/MaskHacker.ts","../../src/proj2d/index.ts","../../src/proj3d/Point3d.ts","../../src/proj3d/Euler.ts","../../src/proj3d/ObservableEuler.ts","../../src/proj3d/Matrix3d.ts","../../src/proj3d/Projection3d.ts","../../src/proj3d/Container3d.ts","../../src/proj3d/Camera3d.ts","../../src/proj3d/mesh/Mesh3d2d.ts","../../src/proj3d/sprites/Sprite3d.ts","../../src/proj3d/sprites/convert.ts","../../src/curve/SpriteBilinearRenderer.ts","../../src/proj3d/sprites/Text3d.ts","../../src/curve/BaseSurface.ts","../../src/curve/BilinearSurface.ts","../../src/curve/ProjectionSurface.ts","../../src/curve/sprites/Sprite2s.ts","../../src/curve/sprites/convert.ts","../../src/curve/sprites/Text2s.ts","../../src/curve/index.ts"],"names":["_getPrototypeOf","o","Object","setPrototypeOf","getPrototypeOf","__proto__","target","property","receiver","Reflect","get","base","object","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","value","_assertThisInitialized","self","ReferenceError","_setPrototypeOf","p","_inherits","subClass","superClass","TypeError","create","constructor","writable","configurable","_typeof","obj","Symbol","iterator","_possibleConstructorReturn","_createSuper","Derived","hasNativeReflectConstruct","construct","sham","Proxy","Date","toString","e","result","Super","NewTarget","this","arguments","apply","convertTo2d","convertTo3d","transformHack"],"mappings":"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","file":"static/js/16.9ba91511.chunk.js","sourcesContent":["export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","import superPropBase from \"@babel/runtime/helpers/esm/superPropBase\";\nexport default function _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nimport possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import { AbstractBatchRenderer, BatchShaderGenerator, Renderer, ViewableBuffer, Buffer, Geometry } from '@pixi/core';\r\nimport { TYPES } from '@pixi/constants';\r\nimport { premultiplyTint } from '@pixi/utils';\r\n\r\nconst shaderVert\r\n    = `precision highp float;\r\nattribute vec3 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\nattribute float aTextureId;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\nvarying float vTextureId;\r\n\r\nvoid main(void){\r\ngl_Position.xyw = projectionMatrix * aVertexPosition;\r\ngl_Position.z = 0.0;\r\n\r\nvTextureCoord = aTextureCoord;\r\nvTextureId = aTextureId;\r\nvColor = aColor;\r\n}\r\n`;\r\nconst shaderFrag = `\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\nvarying float vTextureId;\r\nuniform sampler2D uSamplers[%count%];\r\n\r\nvoid main(void){\r\nvec4 color;\r\n%forloop%\r\ngl_FragColor = color * vColor;\r\n}`;\r\n\r\nexport class Batch3dGeometry extends Geometry\r\n{\r\n    _buffer: Buffer;\r\n    _indexBuffer : Buffer;\r\n\r\n    constructor(_static = false)\r\n    {\r\n        super();\r\n\r\n        this._buffer = new Buffer(null, _static, false);\r\n\r\n        this._indexBuffer = new Buffer(null, _static, true);\r\n\r\n        this.addAttribute('aVertexPosition', this._buffer, 3, false, TYPES.FLOAT)\r\n            .addAttribute('aTextureCoord', this._buffer, 2, false, TYPES.FLOAT)\r\n            .addAttribute('aColor', this._buffer, 4, true, TYPES.UNSIGNED_BYTE)\r\n            .addAttribute('aTextureId', this._buffer, 1, true, TYPES.FLOAT)\r\n            .addIndex(this._indexBuffer);\r\n    }\r\n}\r\n\r\nexport class Batch2dPluginFactory\r\n{\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    static create(options: any): any\r\n    {\r\n        const { vertex, fragment, vertexSize, geometryClass } = (Object as any).assign({\r\n            vertex: shaderVert,\r\n            fragment: shaderFrag,\r\n            geometryClass: Batch3dGeometry,\r\n            vertexSize: 7,\r\n        }, options);\r\n\r\n        return class BatchPlugin extends AbstractBatchRenderer\r\n        {\r\n            constructor(renderer: Renderer)\r\n            {\r\n                super(renderer);\r\n\r\n                this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\r\n                this.geometryClass = geometryClass;\r\n                this.vertexSize = vertexSize;\r\n            }\r\n\r\n            vertexSize: number;\r\n\r\n            // eslint-disable-next-line max-len\r\n            packInterleavedGeometry(element: any, attributeBuffer: ViewableBuffer, indexBuffer: Uint16Array, aIndex: number, iIndex: number)\r\n            {\r\n                const {\r\n                    uint32View,\r\n                    float32View,\r\n                } = attributeBuffer;\r\n\r\n                const p = aIndex / this.vertexSize;// float32View.length / 6 / 2;\r\n                const uvs = element.uvs;\r\n                const indices = element.indices;// geometry.getIndex().data;// indicies;\r\n                const vertexData = element.vertexData;\r\n                const vertexData2d = element.vertexData2d;\r\n                const textureId = element._texture.baseTexture._batchLocation;\r\n\r\n                const alpha = Math.min(element.worldAlpha, 1.0);\r\n\r\n                const argb = alpha < 1.0 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha)\r\n                    : element._tintRGB + (alpha * 255 << 24);\r\n\r\n                if (vertexData2d)\r\n                {\r\n                    let j = 0;\r\n\r\n                    for (let i = 0; i < vertexData2d.length; i += 3, j += 2)\r\n                    {\r\n                        float32View[aIndex++] = vertexData2d[i];\r\n                        float32View[aIndex++] = vertexData2d[i + 1];\r\n                        float32View[aIndex++] = vertexData2d[i + 2];\r\n                        float32View[aIndex++] = uvs[j];\r\n                        float32View[aIndex++] = uvs[j + 1];\r\n                        uint32View[aIndex++] = argb;\r\n                        float32View[aIndex++] = textureId;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    for (let i = 0; i < vertexData.length; i += 2)\r\n                    {\r\n                        float32View[aIndex++] = vertexData[i];\r\n                        float32View[aIndex++] = vertexData[i + 1];\r\n                        float32View[aIndex++] = 1.0;\r\n                        float32View[aIndex++] = uvs[i];\r\n                        float32View[aIndex++] = uvs[i + 1];\r\n                        uint32View[aIndex++] = argb;\r\n                        float32View[aIndex++] = textureId;\r\n                    }\r\n                }\r\n\r\n                for (let i = 0; i < indices.length; i++)\r\n                {\r\n                    indexBuffer[iIndex++] = p + indices[i];\r\n                }\r\n            }\r\n        };\r\n    }\r\n}\r\n","import { Transform } from '@pixi/math';\r\n\r\nexport class AbstractProjection\r\n{\r\n    constructor(legacy: Transform, enable = true)\r\n    {\r\n        this.legacy = legacy;\r\n\r\n        if (enable)\r\n        {\r\n            this.enabled = true;\r\n        }\r\n\r\n        // sorry for hidden class, it would be good to have special projection field in official pixi\r\n        // TODO: pixi 6.1.0 global mixin\r\n        (this.legacy as any).proj = this;\r\n    }\r\n\r\n    legacy: Transform;\r\n\r\n    _enabled = false;\r\n\r\n    get enabled(): boolean\r\n    {\r\n        return this._enabled;\r\n    }\r\n\r\n    set enabled(value: boolean)\r\n    {\r\n        this._enabled = value;\r\n    }\r\n\r\n    clear(): void\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    {\r\n    }\r\n}\r\n\r\nexport enum TRANSFORM_STEP {\r\n    NONE = 0,\r\n    // POS = 1,\r\n    // ROT = 2,\r\n    // SCALE = 3,\r\n    // PIVOT = 4,\r\n    BEFORE_PROJ = 4,\r\n    PROJ = 5,\r\n    // POS_2 = 6,\r\n    // ROT_2 = 7,\r\n    // SCALE_2 = 8,\r\n    // PIVOT_2 = 9,\r\n    ALL = 9\r\n}\r\n","import { AbstractProjection } from './AbstractProjection';\r\nimport { Matrix, Transform } from '@pixi/math';\r\nimport type { Projection2d } from '../proj2d';\r\n\r\nexport enum AFFINE {\r\n    NONE = 0,\r\n    FREE = 1,\r\n    AXIS_X = 2,\r\n    AXIS_Y = 3,\r\n    POINT = 4,\r\n    AXIS_XR = 5\r\n}\r\n\r\nexport function transformHack(this: Transform, parentTransform: Transform): void\r\n{\r\n    // implementation here\r\n    // TODO: pixi 6.1.0 global mixin\r\n    const proj = (this as any).proj as LinearProjection<any>;\r\n    const ta = this as any;\r\n    const pwid = (parentTransform as any)._worldID;\r\n\r\n    const lt = ta.localTransform;\r\n    const scaleAfterAffine = proj.scaleAfterAffine && proj.affine >= 2;\r\n\r\n    // this part is copied from\r\n    if (ta._localID !== ta._currentLocalID)\r\n    {\r\n        // get the matrix values of the displayobject based on its transform properties..\r\n        if (scaleAfterAffine)\r\n        {\r\n            lt.a = ta._cx;\r\n            lt.b = ta._sx;\r\n            lt.c = ta._cy;\r\n            lt.d = ta._sy;\r\n\r\n            lt.tx = ta.position._x;\r\n            lt.ty = ta.position._y;\r\n        }\r\n        else\r\n        {\r\n            lt.a = ta._cx * ta.scale._x;\r\n            lt.b = ta._sx * ta.scale._x;\r\n            lt.c = ta._cy * ta.scale._y;\r\n            lt.d = ta._sy * ta.scale._y;\r\n\r\n            lt.tx = ta.position._x - ((ta.pivot._x * lt.a) + (ta.pivot._y * lt.c));\r\n            lt.ty = ta.position._y - ((ta.pivot._x * lt.b) + (ta.pivot._y * lt.d));\r\n        }\r\n\r\n        ta._currentLocalID = ta._localID;\r\n\r\n        // force an update..\r\n        proj._currentProjID = -1;\r\n    }\r\n\r\n    const _matrixID = proj._projID;\r\n\r\n    if (proj._currentProjID !== _matrixID)\r\n    {\r\n        proj._currentProjID = _matrixID;\r\n        proj.updateLocalTransform(lt);\r\n        ta._parentID = -1;\r\n    }\r\n\r\n    if (ta._parentID !== pwid)\r\n    {\r\n        // TODO: pixi 6.1.0 global mixin\r\n        const pp = (parentTransform as any).proj as Projection2d;\r\n\r\n        if (pp && !pp._affine)\r\n        {\r\n            proj.world.setToMult(pp.world, proj.local);\r\n        }\r\n        else\r\n        {\r\n            proj.world.setToMultLegacy(parentTransform.worldTransform, proj.local);\r\n        }\r\n\r\n        const wa = ta.worldTransform;\r\n\r\n        proj.world.copyTo(wa, proj._affine, proj.affinePreserveOrientation);\r\n\r\n        if (scaleAfterAffine)\r\n        {\r\n            wa.a *= ta.scale._x;\r\n            wa.b *= ta.scale._x;\r\n            wa.c *= ta.scale._y;\r\n            wa.d *= ta.scale._y;\r\n\r\n            wa.tx -= ((ta.pivot._x * wa.a) + (ta.pivot._y * wa.c));\r\n            wa.ty -= ((ta.pivot._x * wa.b) + (ta.pivot._y * wa.d));\r\n        }\r\n        ta._parentID = pwid;\r\n        ta._worldID++;\r\n    }\r\n}\r\n\r\nexport class LinearProjection<T> extends AbstractProjection\r\n{\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    updateLocalTransform(lt: Matrix): void\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    {\r\n    }\r\n\r\n    _projID = 0;\r\n    _currentProjID = -1;\r\n    _affine = AFFINE.NONE;\r\n    affinePreserveOrientation = false;\r\n    scaleAfterAffine = true;\r\n\r\n    set affine(value: AFFINE)\r\n    {\r\n        if (this._affine === value) return;\r\n        this._affine = value;\r\n        this._currentProjID = -1;\r\n        // this is because scaleAfterAffine\r\n        (this.legacy as any)._currentLocalID = -1;\r\n    }\r\n\r\n    get affine(): AFFINE\r\n    {\r\n        return this._affine;\r\n    }\r\n\r\n    local: T;\r\n    world: T;\r\n\r\n    // eslint-disable-next-line accessor-pairs\r\n    set enabled(value: boolean)\r\n    {\r\n        if (value === this._enabled)\r\n        {\r\n            return;\r\n        }\r\n        this._enabled = value;\r\n        if (value)\r\n        {\r\n            this.legacy.updateTransform = transformHack;\r\n            (this.legacy as any)._parentID = -1;\r\n        }\r\n        else\r\n        {\r\n            this.legacy.updateTransform = Transform.prototype.updateTransform;\r\n            (this.legacy as any)._parentID = -1;\r\n        }\r\n    }\r\n\r\n    clear(): void\r\n    {\r\n        this._currentProjID = -1;\r\n        this._projID = 0;\r\n    }\r\n}\r\n","import {\r\n    AbstractBatchRenderer,\r\n    ViewableBuffer,\r\n    BatchTextureArray\r\n} from '@pixi/core';\r\nimport { Dict, premultiplyBlendMode } from '@pixi/utils';\r\nimport { Sprite } from '@pixi/sprite';\r\n\r\nexport class UniformBatchRenderer extends AbstractBatchRenderer\r\n{\r\n    _iIndex: number;\r\n    _aIndex: number;\r\n    _dcIndex: number;\r\n    _bufferedElements: Array<any>;\r\n    _attributeBuffer: ViewableBuffer;\r\n    _indexBuffer: Uint16Array;\r\n    vertexSize: number;\r\n    forceMaxTextures = 0;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    getUniforms(sprite: Sprite): any\r\n    {\r\n        return this.defUniforms;\r\n    }\r\n\r\n    syncUniforms(obj: Dict<any>): void\r\n    {\r\n        if (!obj) return;\r\n        const sh = this._shader;\r\n\r\n        for (const key in obj)\r\n        {\r\n            sh.uniforms[key] = obj[key];\r\n        }\r\n    }\r\n\r\n    defUniforms = {};\r\n\r\n    buildDrawCalls(texArray: BatchTextureArray, start: number, finish: number): void\r\n    {\r\n        const thisAny = this as any;\r\n\r\n        const {\r\n            _bufferedElements: elements,\r\n            _attributeBuffer,\r\n            _indexBuffer,\r\n            vertexSize,\r\n        } = this;\r\n        const drawCalls = AbstractBatchRenderer._drawCallPool;\r\n\r\n        let dcIndex: number = this._dcIndex;\r\n        let aIndex: number = this._aIndex;\r\n        let iIndex: number = this._iIndex;\r\n\r\n        let drawCall = drawCalls[dcIndex] as any;\r\n\r\n        drawCall.start = this._iIndex;\r\n        drawCall.texArray = texArray;\r\n\r\n        for (let i = start; i < finish; ++i)\r\n        {\r\n            const sprite = elements[i];\r\n            const tex = sprite._texture.baseTexture;\r\n            const spriteBlendMode = premultiplyBlendMode[\r\n                tex.alphaMode ? 1 : 0][sprite.blendMode];\r\n            const uniforms = this.getUniforms(sprite);\r\n\r\n            elements[i] = null;\r\n\r\n            // here is the difference\r\n            if (start < i && (drawCall.blend !== spriteBlendMode || drawCall.uniforms !== uniforms))\r\n            {\r\n                drawCall.size = iIndex - drawCall.start;\r\n                start = i;\r\n                drawCall = drawCalls[++dcIndex];\r\n                drawCall.texArray = texArray;\r\n                drawCall.start = iIndex;\r\n            }\r\n\r\n            this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);\r\n            aIndex += sprite.vertexData.length / 2 * vertexSize;\r\n            iIndex += sprite.indices.length;\r\n\r\n            drawCall.blend = spriteBlendMode;\r\n            // here is the difference\r\n            drawCall.uniforms = uniforms;\r\n        }\r\n\r\n        if (start < finish)\r\n        {\r\n            drawCall.size = iIndex - drawCall.start;\r\n            ++dcIndex;\r\n        }\r\n\r\n        thisAny._dcIndex = dcIndex;\r\n        thisAny._aIndex = aIndex;\r\n        thisAny._iIndex = iIndex;\r\n    }\r\n\r\n    drawBatches(): void\r\n    {\r\n        const dcCount = this._dcIndex;\r\n        const { gl, state: stateSystem, shader: shaderSystem } = this.renderer;\r\n        const drawCalls = AbstractBatchRenderer._drawCallPool;\r\n        let curUniforms: any = null;\r\n        let curTexArray: BatchTextureArray = null;\r\n\r\n        for (let i = 0; i < dcCount; i++)\r\n        {\r\n            const { texArray, type, size, start, blend, uniforms } = drawCalls[i] as any;\r\n\r\n            if (curTexArray !== texArray)\r\n            {\r\n                curTexArray = texArray;\r\n                this.bindAndClearTexArray(texArray);\r\n            }\r\n            // here is the difference\r\n            if (curUniforms !== uniforms)\r\n            {\r\n                curUniforms = uniforms;\r\n                this.syncUniforms(uniforms);\r\n                (shaderSystem as any).syncUniformGroup((this._shader as any).uniformGroup);\r\n            }\r\n\r\n            this.state.blendMode = blend;\r\n            stateSystem.set(this.state);\r\n            gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\r\n        }\r\n    }\r\n\r\n    contextChange(): void\r\n    {\r\n        if (!this.forceMaxTextures)\r\n        {\r\n            super.contextChange();\r\n            this.syncUniforms(this.defUniforms);\r\n\r\n            return;\r\n        }\r\n\r\n        // we can override MAX_TEXTURES with this hack\r\n\r\n        const thisAny = this as any;\r\n\r\n        thisAny.MAX_TEXTURES = this.forceMaxTextures;\r\n        this._shader = thisAny.shaderGenerator.generateShader(this.MAX_TEXTURES);\r\n        this.syncUniforms(this.defUniforms);\r\n        for (let i = 0; i < thisAny._packedGeometryPoolSize; i++)\r\n        {\r\n            /* eslint-disable max-len */\r\n            thisAny._packedGeometries[i] = new (this.geometryClass)();\r\n        }\r\n        this.initFlushBuffers();\r\n    }\r\n}\r\n","import { Renderer } from '@pixi/core';\r\nimport { Batch2dPluginFactory } from './webgl/Sprite2dRenderer';\r\n\r\nexport * from './AbstractProjection';\r\nexport * from './LinearProjection';\r\nexport * from './webgl/Sprite2dRenderer';\r\nexport * from './webgl/UniformBatchRenderer';\r\n\r\nRenderer.registerPlugin('batch2d', Batch2dPluginFactory.create({}));\r\n","/* eslint-disable no-mixed-operators,max-statements-per-line */\r\n// according to https://jsperf.com/obj-vs-array-view-access/1 , Float64Array is the best here\r\nimport { IPointData, Matrix, Point } from '@pixi/math';\r\nimport { AFFINE } from '../base';\r\n\r\nconst mat3id = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n\r\nexport class Matrix2d\r\n{\r\n    /**\r\n     * A default (identity) matrix\r\n     *\r\n     * @static\r\n     * @const\r\n     */\r\n    static readonly IDENTITY = new Matrix2d();\r\n\r\n    /**\r\n     * A temp matrix\r\n     *\r\n     * @static\r\n     * @const\r\n     */\r\n    static readonly TEMP_MATRIX = new Matrix2d();\r\n\r\n    /**\r\n     * mat3 implementation through array of 9 elements\r\n     */\r\n    mat3: Float64Array;\r\n\r\n    floatArray: Float32Array = null;\r\n\r\n    constructor(backingArray?: ArrayLike<number>)\r\n    {\r\n        this.mat3 = new Float64Array(backingArray || mat3id);\r\n    }\r\n\r\n    get a(): number\r\n    {\r\n        return this.mat3[0] / this.mat3[8];\r\n    }\r\n\r\n    set a(value: number)\r\n    {\r\n        this.mat3[0] = value * this.mat3[8];\r\n    }\r\n\r\n    get b(): number\r\n    {\r\n        return this.mat3[1] / this.mat3[8];\r\n    }\r\n\r\n    set b(value: number)\r\n    {\r\n        this.mat3[1] = value * this.mat3[8];\r\n    }\r\n\r\n    get c(): number\r\n    {\r\n        return this.mat3[3] / this.mat3[8];\r\n    }\r\n\r\n    set c(value: number)\r\n    {\r\n        this.mat3[3] = value * this.mat3[8];\r\n    }\r\n\r\n    get d(): number\r\n    {\r\n        return this.mat3[4] / this.mat3[8];\r\n    }\r\n\r\n    set d(value: number)\r\n    {\r\n        this.mat3[4] = value * this.mat3[8];\r\n    }\r\n\r\n    get tx(): number\r\n    {\r\n        return this.mat3[6] / this.mat3[8];\r\n    }\r\n\r\n    set tx(value: number)\r\n    {\r\n        this.mat3[6] = value * this.mat3[8];\r\n    }\r\n\r\n    get ty(): number\r\n    {\r\n        return this.mat3[7] / this.mat3[8];\r\n    }\r\n\r\n    set ty(value: number)\r\n    {\r\n        this.mat3[7] = value * this.mat3[8];\r\n    }\r\n\r\n    set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\r\n    {\r\n        const mat3 = this.mat3;\r\n\r\n        mat3[0] = a;\r\n        mat3[1] = b;\r\n        mat3[2] = 0;\r\n        mat3[3] = c;\r\n        mat3[4] = d;\r\n        mat3[5] = 0;\r\n        mat3[6] = tx;\r\n        mat3[7] = ty;\r\n        mat3[8] = 1;\r\n\r\n        return this;\r\n    }\r\n\r\n    toArray(transpose?: boolean, out?: Float32Array): Float32Array\r\n    {\r\n        if (!this.floatArray)\r\n        {\r\n            this.floatArray = new Float32Array(9);\r\n        }\r\n\r\n        const array = out || this.floatArray;\r\n        const mat3 = this.mat3;\r\n\r\n        if (transpose)\r\n        {\r\n            array[0] = mat3[0];\r\n            array[1] = mat3[1];\r\n            array[2] = mat3[2];\r\n            array[3] = mat3[3];\r\n            array[4] = mat3[4];\r\n            array[5] = mat3[5];\r\n            array[6] = mat3[6];\r\n            array[7] = mat3[7];\r\n            array[8] = mat3[8];\r\n        }\r\n        else\r\n        {\r\n            // this branch is NEVER USED in pixi\r\n            array[0] = mat3[0];\r\n            array[1] = mat3[3];\r\n            array[2] = mat3[6];\r\n            array[3] = mat3[1];\r\n            array[4] = mat3[4];\r\n            array[5] = mat3[7];\r\n            array[6] = mat3[2];\r\n            array[7] = mat3[5];\r\n            array[8] = mat3[8];\r\n        }\r\n\r\n        return array;\r\n    }\r\n\r\n    // TODO: remove props\r\n    apply(pos: IPointData, newPos: IPointData): IPointData\r\n    {\r\n        newPos = newPos || new Point();\r\n\r\n        const mat3 = this.mat3;\r\n        const x = pos.x;\r\n        const y = pos.y;\r\n\r\n        const z = 1.0 / (mat3[2] * x + mat3[5] * y + mat3[8]);\r\n\r\n        newPos.x = z * (mat3[0] * x + mat3[3] * y + mat3[6]);\r\n        newPos.y = z * (mat3[1] * x + mat3[4] * y + mat3[7]);\r\n\r\n        return newPos;\r\n    }\r\n\r\n    translate(tx: number, ty: number): this\r\n    {\r\n        const mat3 = this.mat3;\r\n\r\n        mat3[0] += tx * mat3[2];\r\n        mat3[1] += ty * mat3[2];\r\n        mat3[3] += tx * mat3[5];\r\n        mat3[4] += ty * mat3[5];\r\n        mat3[6] += tx * mat3[8];\r\n        mat3[7] += ty * mat3[8];\r\n\r\n        return this;\r\n    }\r\n\r\n    scale(x: number, y: number): this\r\n    {\r\n        const mat3 = this.mat3;\r\n\r\n        mat3[0] *= x;\r\n        mat3[1] *= y;\r\n        mat3[3] *= x;\r\n        mat3[4] *= y;\r\n        mat3[6] *= x;\r\n        mat3[7] *= y;\r\n\r\n        return this;\r\n    }\r\n\r\n    scaleAndTranslate(scaleX: number, scaleY: number, tx: number, ty: number): void\r\n    {\r\n        const mat3 = this.mat3;\r\n\r\n        mat3[0] = scaleX * mat3[0] + tx * mat3[2];\r\n        mat3[1] = scaleY * mat3[1] + ty * mat3[2];\r\n        mat3[3] = scaleX * mat3[3] + tx * mat3[5];\r\n        mat3[4] = scaleY * mat3[4] + ty * mat3[5];\r\n        mat3[6] = scaleX * mat3[6] + tx * mat3[8];\r\n        mat3[7] = scaleY * mat3[7] + ty * mat3[8];\r\n    }\r\n\r\n    // TODO: remove props\r\n    applyInverse(pos: IPointData, newPos: IPointData): IPointData\r\n    {\r\n        newPos = newPos || new Point();\r\n\r\n        const a = this.mat3;\r\n        const x = pos.x;\r\n        const y = pos.y;\r\n\r\n        const a00 = a[0]; const a01 = a[3]; const a02 = a[6];\r\n        const a10 = a[1]; const a11 = a[4]; const a12 = a[7];\r\n        const a20 = a[2]; const a21 = a[5]; const\r\n            a22 = a[8];\r\n\r\n        const newX = (a22 * a11 - a12 * a21) * x + (-a22 * a01 + a02 * a21) * y + (a12 * a01 - a02 * a11);\r\n        const newY = (-a22 * a10 + a12 * a20) * x + (a22 * a00 - a02 * a20) * y + (-a12 * a00 + a02 * a10);\r\n        const newZ = (a21 * a10 - a11 * a20) * x + (-a21 * a00 + a01 * a20) * y + (a11 * a00 - a01 * a10);\r\n\r\n        newPos.x = newX / newZ;\r\n        newPos.y = newY / newZ;\r\n\r\n        return newPos;\r\n    }\r\n\r\n    invert(): Matrix2d\r\n    {\r\n        const a = this.mat3;\r\n\r\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2];\r\n        const a10 = a[3]; const a11 = a[4]; const a12 = a[5];\r\n        const a20 = a[6]; const a21 = a[7]; const a22 = a[8];\r\n\r\n        const b01 = a22 * a11 - a12 * a21;\r\n        const b11 = -a22 * a10 + a12 * a20;\r\n        const b21 = a21 * a10 - a11 * a20;\r\n\r\n        // Calculate the determinant\r\n        let det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n        if (!det)\r\n        {\r\n            return this;\r\n        }\r\n        det = 1.0 / det;\r\n\r\n        a[0] = b01 * det;\r\n        a[1] = (-a22 * a01 + a02 * a21) * det;\r\n        a[2] = (a12 * a01 - a02 * a11) * det;\r\n        a[3] = b11 * det;\r\n        a[4] = (a22 * a00 - a02 * a20) * det;\r\n        a[5] = (-a12 * a00 + a02 * a10) * det;\r\n        a[6] = b21 * det;\r\n        a[7] = (-a21 * a00 + a01 * a20) * det;\r\n        a[8] = (a11 * a00 - a01 * a10) * det;\r\n\r\n        return this;\r\n    }\r\n\r\n    identity(): Matrix2d\r\n    {\r\n        const mat3 = this.mat3;\r\n\r\n        mat3[0] = 1;\r\n        mat3[1] = 0;\r\n        mat3[2] = 0;\r\n        mat3[3] = 0;\r\n        mat3[4] = 1;\r\n        mat3[5] = 0;\r\n        mat3[6] = 0;\r\n        mat3[7] = 0;\r\n        mat3[8] = 1;\r\n\r\n        return this;\r\n    }\r\n\r\n    clone(): Matrix2d\r\n    {\r\n        return new Matrix2d(this.mat3);\r\n    }\r\n\r\n    copyTo2dOr3d(matrix: Matrix2d): Matrix2d\r\n    {\r\n        const mat3 = this.mat3;\r\n        const ar2 = matrix.mat3;\r\n\r\n        ar2[0] = mat3[0];\r\n        ar2[1] = mat3[1];\r\n        ar2[2] = mat3[2];\r\n        ar2[3] = mat3[3];\r\n        ar2[4] = mat3[4];\r\n        ar2[5] = mat3[5];\r\n        ar2[6] = mat3[6];\r\n        ar2[7] = mat3[7];\r\n        ar2[8] = mat3[8];\r\n\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * legacy method, change the values of given pixi matrix\r\n     * @param matrix\r\n     * @param affine\r\n     * @param preserveOrientation\r\n     * @return matrix\r\n     */\r\n    copyTo(matrix: Matrix, affine?: AFFINE, preserveOrientation?: boolean): Matrix\r\n    {\r\n        const mat3 = this.mat3;\r\n        const d = 1.0 / mat3[8];\r\n        const tx = mat3[6] * d; const\r\n            ty = mat3[7] * d;\r\n\r\n        matrix.a = (mat3[0] - mat3[2] * tx) * d;\r\n        matrix.b = (mat3[1] - mat3[2] * ty) * d;\r\n        matrix.c = (mat3[3] - mat3[5] * tx) * d;\r\n        matrix.d = (mat3[4] - mat3[5] * ty) * d;\r\n        matrix.tx = tx;\r\n        matrix.ty = ty;\r\n\r\n        if (affine >= 2)\r\n        {\r\n            let D = matrix.a * matrix.d - matrix.b * matrix.c;\r\n\r\n            if (!preserveOrientation)\r\n            {\r\n                D = Math.abs(D);\r\n            }\r\n            if (affine === AFFINE.POINT)\r\n            {\r\n                if (D > 0)\r\n                {\r\n                    D = 1;\r\n                }\r\n                else D = -1;\r\n                matrix.a = D;\r\n                matrix.b = 0;\r\n                matrix.c = 0;\r\n                matrix.d = D;\r\n            }\r\n            else if (affine === AFFINE.AXIS_X)\r\n            {\r\n                D /= Math.sqrt(matrix.b * matrix.b + matrix.d * matrix.d);\r\n                matrix.c = 0;\r\n                matrix.d = D;\r\n            }\r\n            else if (affine === AFFINE.AXIS_Y)\r\n            {\r\n                D /= Math.sqrt(matrix.a * matrix.a + matrix.c * matrix.c);\r\n                matrix.a = D;\r\n                matrix.c = 0;\r\n            }\r\n            else if (affine === AFFINE.AXIS_XR)\r\n            {\r\n                matrix.a = matrix.d * D;\r\n                matrix.c = -matrix.b * D;\r\n            }\r\n        }\r\n\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * legacy method, change the values of given pixi matrix\r\n     * @param matrix\r\n     * @return\r\n     */\r\n    copyFrom(matrix: Matrix): this\r\n    {\r\n        const mat3 = this.mat3;\r\n\r\n        mat3[0] = matrix.a;\r\n        mat3[1] = matrix.b;\r\n        mat3[2] = 0;\r\n        mat3[3] = matrix.c;\r\n        mat3[4] = matrix.d;\r\n        mat3[5] = 0;\r\n        mat3[6] = matrix.tx;\r\n        mat3[7] = matrix.ty;\r\n        mat3[8] = 1.0;\r\n\r\n        return this;\r\n    }\r\n\r\n    setToMultLegacy(pt: Matrix, lt: Matrix2d): this\r\n    {\r\n        const out = this.mat3;\r\n        const b = lt.mat3;\r\n\r\n        const a00 = pt.a; const a01 = pt.b;\r\n        const a10 = pt.c; const a11 = pt.d;\r\n        const a20 = pt.tx; const a21 = pt.ty;\r\n\r\n        const b00 = b[0]; const b01 = b[1]; const b02 = b[2];\r\n        const b10 = b[3]; const b11 = b[4]; const b12 = b[5];\r\n        const b20 = b[6]; const b21 = b[7]; const\r\n            b22 = b[8];\r\n\r\n        out[0] = b00 * a00 + b01 * a10 + b02 * a20;\r\n        out[1] = b00 * a01 + b01 * a11 + b02 * a21;\r\n        out[2] = b02;\r\n\r\n        out[3] = b10 * a00 + b11 * a10 + b12 * a20;\r\n        out[4] = b10 * a01 + b11 * a11 + b12 * a21;\r\n        out[5] = b12;\r\n\r\n        out[6] = b20 * a00 + b21 * a10 + b22 * a20;\r\n        out[7] = b20 * a01 + b21 * a11 + b22 * a21;\r\n        out[8] = b22;\r\n\r\n        return this;\r\n    }\r\n\r\n    setToMultLegacy2(pt: Matrix2d, lt: Matrix): this\r\n    {\r\n        const out = this.mat3;\r\n        const a = pt.mat3;\r\n\r\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2];\r\n        const a10 = a[3]; const a11 = a[4]; const a12 = a[5];\r\n        const a20 = a[6]; const a21 = a[7]; const a22 = a[8];\r\n\r\n        const b00 = lt.a; const b01 = lt.b;\r\n        const b10 = lt.c; const b11 = lt.d;\r\n        const b20 = lt.tx; const\r\n            b21 = lt.ty;\r\n\r\n        out[0] = b00 * a00 + b01 * a10;\r\n        out[1] = b00 * a01 + b01 * a11;\r\n        out[2] = b00 * a02 + b01 * a12;\r\n\r\n        out[3] = b10 * a00 + b11 * a10;\r\n        out[4] = b10 * a01 + b11 * a11;\r\n        out[5] = b10 * a02 + b11 * a12;\r\n\r\n        out[6] = b20 * a00 + b21 * a10 + a20;\r\n        out[7] = b20 * a01 + b21 * a11 + a21;\r\n        out[8] = b20 * a02 + b21 * a12 + a22;\r\n\r\n        return this;\r\n    }\r\n\r\n    // that's transform multiplication we use\r\n    setToMult(pt: Matrix2d, lt: Matrix2d): this\r\n    {\r\n        const out = this.mat3;\r\n        const a = pt.mat3; const\r\n            b = lt.mat3;\r\n\r\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2];\r\n        const a10 = a[3]; const a11 = a[4]; const a12 = a[5];\r\n        const a20 = a[6]; const a21 = a[7]; const a22 = a[8];\r\n\r\n        const b00 = b[0]; const b01 = b[1]; const b02 = b[2];\r\n        const b10 = b[3]; const b11 = b[4]; const b12 = b[5];\r\n        const b20 = b[6]; const b21 = b[7]; const\r\n            b22 = b[8];\r\n\r\n        out[0] = b00 * a00 + b01 * a10 + b02 * a20;\r\n        out[1] = b00 * a01 + b01 * a11 + b02 * a21;\r\n        out[2] = b00 * a02 + b01 * a12 + b02 * a22;\r\n\r\n        out[3] = b10 * a00 + b11 * a10 + b12 * a20;\r\n        out[4] = b10 * a01 + b11 * a11 + b12 * a21;\r\n        out[5] = b10 * a02 + b11 * a12 + b12 * a22;\r\n\r\n        out[6] = b20 * a00 + b21 * a10 + b22 * a20;\r\n        out[7] = b20 * a01 + b21 * a11 + b22 * a21;\r\n        out[8] = b20 * a02 + b21 * a12 + b22 * a22;\r\n\r\n        return this;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    prepend(lt: any): this\r\n    {\r\n        if (lt.mat3)\r\n        {\r\n            return this.setToMult(lt, this);\r\n        }\r\n\r\n        return this.setToMultLegacy(lt, this);\r\n    }\r\n}\r\n","import { Matrix2d } from '../Matrix2d';\r\nimport { ObjectRenderer, QuadUv, Renderer, Shader } from '@pixi/core';\r\nimport { DRAW_MODES, WRAP_MODES } from '@pixi/constants';\r\nimport { correctBlendMode, premultiplyTintToRgba } from '@pixi/utils';\r\n\r\nconst shaderVert\r\n    = `attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTransform;\r\n\r\nvarying vec3 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\r\n\r\nvTextureCoord = uTransform * vec3(aTextureCoord, 1.0);\r\n}\r\n`;\r\nconst shaderFrag = `\r\nvarying vec3 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec4 uColor;\r\nuniform mat3 uMapCoord;\r\nuniform vec4 uClampFrame;\r\nuniform vec2 uClampOffset;\r\n\r\nvoid main(void)\r\n{\r\nvec2 coord = mod(vTextureCoord.xy / vTextureCoord.z - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\r\ncoord = (uMapCoord * vec3(coord, 1.0)).xy;\r\ncoord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\r\n\r\nvec4 sample = texture2D(uSampler, coord);\r\ngl_FragColor = sample * uColor;\r\n}\r\n`;\r\nconst shaderSimpleFrag = `\r\nvarying vec3 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec4 uColor;\r\n\r\nvoid main(void)\r\n{\r\nvec4 sample = texture2D(uSampler, vTextureCoord.xy / vTextureCoord.z);\r\ngl_FragColor = sample * uColor;\r\n}\r\n`;\r\n\r\n// changed\r\nconst tempMat = new Matrix2d();\r\n\r\nexport class TilingSprite2dRenderer extends ObjectRenderer\r\n{\r\n    constructor(renderer: Renderer)\r\n    {\r\n        super(renderer);\r\n\r\n        const uniforms = { globals: this.renderer.globalUniforms };\r\n\r\n        this.shader = Shader.from(shaderVert, shaderFrag, uniforms);\r\n\r\n        this.simpleShader = Shader.from(shaderVert, shaderSimpleFrag, uniforms);\r\n    }\r\n\r\n    shader: Shader;\r\n    simpleShader: Shader;\r\n    quad = new QuadUv();\r\n\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    render(ts: any): void\r\n    {\r\n        const renderer = this.renderer;\r\n        const quad = this.quad;\r\n\r\n        let vertices = quad.vertices;\r\n\r\n        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;\r\n        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\r\n\r\n        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);\r\n        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\r\n\r\n        if (ts.uvRespectAnchor)\r\n        {\r\n            vertices = quad.uvs;\r\n\r\n            vertices[0] = vertices[6] = -ts.anchor.x;\r\n            vertices[1] = vertices[3] = -ts.anchor.y;\r\n\r\n            vertices[2] = vertices[4] = 1.0 - ts.anchor.x;\r\n            vertices[5] = vertices[7] = 1.0 - ts.anchor.y;\r\n        }\r\n\r\n        quad.invalidate();\r\n\r\n        const tex = ts._texture;\r\n        const baseTex = tex.baseTexture;\r\n        const lt = ts.tileProj.world;\r\n        const uv = ts.uvMatrix;\r\n        let isSimple = baseTex.isPowerOfTwo\r\n            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\r\n\r\n        // auto, force repeat wrapMode for big tiling textures\r\n        if (isSimple)\r\n        {\r\n            if (!baseTex._glTextures[(renderer as any).CONTEXT_UID])\r\n            {\r\n                if (baseTex.wrapMode === WRAP_MODES.CLAMP)\r\n                {\r\n                    baseTex.wrapMode = WRAP_MODES.REPEAT;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\r\n            }\r\n        }\r\n\r\n        const shader = isSimple ? this.simpleShader : this.shader;\r\n\r\n        // changed\r\n        tempMat.identity();\r\n        tempMat.scale(tex.width, tex.height);\r\n        tempMat.prepend(lt);\r\n        tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\r\n\r\n        tempMat.invert();\r\n        if (isSimple)\r\n        {\r\n            tempMat.prepend(uv.mapCoord);\r\n        }\r\n        else\r\n        {\r\n            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\r\n            shader.uniforms.uClampFrame = uv.uClampFrame;\r\n            shader.uniforms.uClampOffset = uv.uClampOffset;\r\n        }\r\n\r\n        shader.uniforms.uTransform = tempMat.toArray(true);\r\n        shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha,\r\n            shader.uniforms.uColor, baseTex.premultiplyAlpha);\r\n        shader.uniforms.translationMatrix = ts.worldTransform.toArray(true);\r\n        shader.uniforms.uSampler = tex;\r\n\r\n        renderer.shader.bind(shader, false);\r\n        renderer.geometry.bind(quad as any, undefined);// , renderer.shader.getGLShader());\r\n\r\n        renderer.state.setBlendMode(correctBlendMode(ts.blendMode, baseTex.premultiplyAlpha));\r\n        renderer.geometry.draw(DRAW_MODES.TRIANGLES, 6, 0);\r\n    }\r\n}\r\n","/* eslint-disable no-mixed-operators */\r\nimport { Matrix2d } from './Matrix2d';\r\nimport { IPointData, Matrix, ObservablePoint, Point, Rectangle, Transform } from '@pixi/math';\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { LinearProjection } from '../base';\r\nimport { getIntersectionFactor } from '../utils';\r\n\r\nconst t0 = new Point();\r\nconst tt = [new Point(), new Point(), new Point(), new Point()];\r\nconst tempRect = new Rectangle();\r\nconst tempMat = new Matrix2d();\r\n\r\nexport class Projection2d extends LinearProjection<Matrix2d>\r\n{\r\n    constructor(legacy: Transform, enable?: boolean)\r\n    {\r\n        super(legacy, enable);\r\n        this.local = new Matrix2d();\r\n        this.world = new Matrix2d();\r\n    }\r\n\r\n    matrix = new Matrix2d();\r\n    pivot = new ObservablePoint(this.onChange, this, 0, 0);\r\n\r\n    reverseLocalOrder = false;\r\n\r\n    onChange(): void\r\n    {\r\n        const pivot = this.pivot;\r\n        const mat3 = this.matrix.mat3;\r\n\r\n        mat3[6] = -(pivot._x * mat3[0] + pivot._y * mat3[3]);\r\n        mat3[7] = -(pivot._x * mat3[1] + pivot._y * mat3[4]);\r\n\r\n        this._projID++;\r\n    }\r\n\r\n    setAxisX(p: IPointData, factor = 1): void\r\n    {\r\n        const x = p.x; const\r\n            y = p.y;\r\n        const d = Math.sqrt(x * x + y * y);\r\n        const mat3 = this.matrix.mat3;\r\n\r\n        mat3[0] = x / d;\r\n        mat3[1] = y / d;\r\n        mat3[2] = factor / d;\r\n\r\n        this.onChange();\r\n    }\r\n\r\n    setAxisY(p: IPointData, factor = 1): void\r\n    {\r\n        const x = p.x; const\r\n            y = p.y;\r\n        const d = Math.sqrt(x * x + y * y);\r\n        const mat3 = this.matrix.mat3;\r\n\r\n        mat3[3] = x / d;\r\n        mat3[4] = y / d;\r\n        mat3[5] = factor / d;\r\n        this.onChange();\r\n    }\r\n\r\n    mapSprite(sprite: Sprite, quad: Array<IPointData>): void\r\n    {\r\n        const tex = sprite.texture;\r\n\r\n        tempRect.x = -sprite.anchor.x * tex.orig.width;\r\n        tempRect.y = -sprite.anchor.y * tex.orig.height;\r\n        tempRect.width = tex.orig.width;\r\n        tempRect.height = tex.orig.height;\r\n\r\n        this.mapQuad(tempRect, quad);\r\n    }\r\n\r\n    mapQuad(rect: Rectangle, p: Array<IPointData>): void\r\n    {\r\n        // utils.getPositionFromQuad(p, anchor, t0);\r\n        tt[0].set(rect.x, rect.y);\r\n        tt[1].set(rect.x + rect.width, rect.y);\r\n        tt[2].set(rect.x + rect.width, rect.y + rect.height);\r\n        tt[3].set(rect.x, rect.y + rect.height);\r\n\r\n        let k1 = 1; let k2 = 2;\r\n        let k3 = 3;\r\n        const f = getIntersectionFactor(p[0], p[2], p[1], p[3], t0);\r\n\r\n        if (f !== 0)\r\n        {\r\n            k1 = 1;\r\n            k2 = 3;\r\n            k3 = 2;\r\n        }\r\n        else\r\n        {\r\n            return;\r\n            /* f = utils.getIntersectionFactor(p[0], p[1], p[2], p[3], t0);\r\n            if (f > 0) {\r\n                k1 = 2;\r\n                k2 = 3;\r\n                k3 = 1;\r\n            } else {\r\n                f = utils.getIntersectionFactor(p[0], p[3], p[1], p[2], t0);\r\n                if (f > 0) {\r\n                    // cant find it :(\r\n                    k1 = 1;\r\n                    k2 = 2;\r\n                    k3 = 3;\r\n                } else {\r\n                    return;\r\n                }\r\n            }*/\r\n        }\r\n        const d0 = Math.sqrt((p[0].x - t0.x) * (p[0].x - t0.x) + (p[0].y - t0.y) * (p[0].y - t0.y));\r\n        const d1 = Math.sqrt((p[k1].x - t0.x) * (p[k1].x - t0.x) + (p[k1].y - t0.y) * (p[k1].y - t0.y));\r\n        const d2 = Math.sqrt((p[k2].x - t0.x) * (p[k2].x - t0.x) + (p[k2].y - t0.y) * (p[k2].y - t0.y));\r\n        const d3 = Math.sqrt((p[k3].x - t0.x) * (p[k3].x - t0.x) + (p[k3].y - t0.y) * (p[k3].y - t0.y));\r\n\r\n        const q0 = (d0 + d3) / d3;\r\n        const q1 = (d1 + d2) / d2;\r\n        const q2 = (d1 + d2) / d1;\r\n\r\n        let mat3 = this.matrix.mat3;\r\n\r\n        mat3[0] = tt[0].x * q0;\r\n        mat3[1] = tt[0].y * q0;\r\n        mat3[2] = q0;\r\n        mat3[3] = tt[k1].x * q1;\r\n        mat3[4] = tt[k1].y * q1;\r\n        mat3[5] = q1;\r\n        mat3[6] = tt[k2].x * q2;\r\n        mat3[7] = tt[k2].y * q2;\r\n        mat3[8] = q2;\r\n        this.matrix.invert();\r\n\r\n        mat3 = tempMat.mat3;\r\n        mat3[0] = p[0].x;\r\n        mat3[1] = p[0].y;\r\n        mat3[2] = 1;\r\n        mat3[3] = p[k1].x;\r\n        mat3[4] = p[k1].y;\r\n        mat3[5] = 1;\r\n        mat3[6] = p[k2].x;\r\n        mat3[7] = p[k2].y;\r\n        mat3[8] = 1;\r\n\r\n        this.matrix.setToMult(tempMat, this.matrix);\r\n        this._projID++;\r\n    }\r\n\r\n    updateLocalTransform(lt: Matrix): void\r\n    {\r\n        if (this._projID !== 0)\r\n        {\r\n            if (this.reverseLocalOrder)\r\n            {\r\n                // tilingSprite inside order\r\n                this.local.setToMultLegacy2(this.matrix, lt);\r\n            }\r\n            else\r\n            {\r\n                // good order\r\n                this.local.setToMultLegacy(lt, this.matrix);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.local.copyFrom(lt);\r\n        }\r\n    }\r\n\r\n    clear(): void\r\n    {\r\n        super.clear();\r\n        this.matrix.identity();\r\n        this.pivot.set(0, 0);\r\n    }\r\n}\r\n","/* eslint-disable no-mixed-operators */\r\nimport { IPointData, Point } from '@pixi/math';\r\n\r\n// eslint-disable-next-line max-len\r\nexport function getIntersectionFactor(p1: IPointData, p2: IPointData, p3: IPointData, p4: IPointData, out: IPointData): number\r\n{\r\n    const A1 = p2.x - p1.x; const B1 = p3.x - p4.x;\r\n    const C1 = p3.x - p1.x;\r\n    const A2 = p2.y - p1.y; const B2 = p3.y - p4.y;\r\n    const C2 = p3.y - p1.y;\r\n    const D = A1 * B2 - A2 * B1;\r\n\r\n    if (Math.abs(D) < 1e-7)\r\n    {\r\n        out.x = A1;\r\n        out.y = A2;\r\n\r\n        return 0;\r\n    }\r\n    const T = C1 * B2 - C2 * B1;\r\n    const U = A1 * C2 - A2 * C1;\r\n\r\n    const t = T / D; const\r\n        u = U / D;\r\n\r\n    if (u < (1e-6) || u - 1 > -1e-6)\r\n    {\r\n        return -1;\r\n    }\r\n\r\n    out.x = p1.x + t * (p2.x - p1.x);\r\n    out.y = p1.y + t * (p2.y - p1.y);\r\n\r\n    return 1;\r\n}\r\n\r\nexport function getPositionFromQuad(p: Array<IPointData>, anchor: IPointData, out: IPointData): IPointData\r\n{\r\n    out = out || new Point();\r\n    const a1 = 1.0 - anchor.x; const\r\n        a2 = 1.0 - a1;\r\n    const b1 = 1.0 - anchor.y; const\r\n        b2 = 1.0 - b1;\r\n\r\n    out.x = (p[0].x * a1 + p[1].x * a2) * b1 + (p[3].x * a1 + p[2].x * a2) * b2;\r\n    out.y = (p[0].y * a1 + p[1].y * a2) * b1 + (p[3].y * a1 + p[2].y * a2) * b2;\r\n\r\n    return out;\r\n}\r\n","import { Projection2d } from './Projection2d';\r\nimport { Container, DisplayObject } from '@pixi/display';\r\nimport { IPointData, Matrix, Point } from '@pixi/math';\r\nimport { TRANSFORM_STEP } from '../base';\r\n\r\nexport function container2dWorldTransform(): Matrix\r\n{\r\n    return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\r\n}\r\n\r\nexport class Container2d extends Container\r\n{\r\n    constructor()\r\n    {\r\n        super();\r\n        this.proj = new Projection2d(this.transform);\r\n    }\r\n\r\n    proj: Projection2d;\r\n\r\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean,\r\n        step = TRANSFORM_STEP.ALL): P\r\n    {\r\n        if (from)\r\n        {\r\n            position = from.toGlobal(position, point, skipUpdate);\r\n        }\r\n\r\n        if (!skipUpdate)\r\n        {\r\n            this._recursivePostUpdateTransform();\r\n        }\r\n\r\n        if (step >= TRANSFORM_STEP.PROJ)\r\n        {\r\n            if (!skipUpdate)\r\n            {\r\n                this.displayObjectUpdateTransform();\r\n            }\r\n            if (this.proj.affine)\r\n            {\r\n                return this.transform.worldTransform.applyInverse(position, point) as any;\r\n            }\r\n\r\n            return this.proj.world.applyInverse(position, point) as any;\r\n        }\r\n\r\n        if (this.parent)\r\n        {\r\n            point = this.parent.worldTransform.applyInverse(position, point) as any;\r\n        }\r\n        else\r\n        {\r\n            point.x = position.x;\r\n            point.y = position.y;\r\n        }\r\n        if (step === TRANSFORM_STEP.NONE)\r\n        {\r\n            return point;\r\n        }\r\n\r\n        return this.transform.localTransform.applyInverse(point, point) as any;\r\n    }\r\n\r\n    get worldTransform(): Matrix\r\n    {\r\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\r\n    }\r\n}\r\n\r\nexport const container2dToLocal = Container2d.prototype.toLocal;\r\n","import { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';\r\nimport { Geometry, Program, Renderer, State, Texture } from '@pixi/core';\r\nimport { Projection2d } from '../Projection2d';\r\nimport { IPointData, Matrix } from '@pixi/math';\r\nimport { DisplayObject } from '@pixi/display';\r\nimport { TRANSFORM_STEP } from '../../base';\r\nimport { container2dToLocal } from '../Container2d';\r\n\r\nexport class Mesh2d extends Mesh\r\n{\r\n    static defaultVertexShader =\r\n        `precision highp float;\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\r\ngl_Position.z = 0.0;\r\n\r\nvTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n`;\r\n    static defaultFragmentShader = `\r\nvarying vec2 vTextureCoord;\r\nuniform vec4 uColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void)\r\n{\r\ngl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\r\n}`;\r\n    constructor(geometry: Geometry, shader: MeshMaterial, state: State, drawMode?: number)\r\n    {\r\n        super(geometry, shader, state, drawMode);\r\n        this.proj = new Projection2d(this.transform);\r\n    }\r\n\r\n    vertexData2d: Float32Array = null;\r\n    proj: Projection2d;\r\n\r\n    calculateVertices(): void\r\n    {\r\n        if (this.proj._affine)\r\n        {\r\n            this.vertexData2d = null;\r\n            super.calculateVertices();\r\n\r\n            return;\r\n        }\r\n\r\n        const geometry = this.geometry as any;\r\n        const vertices = geometry.buffers[0].data;\r\n        const thisAny = this as any;\r\n\r\n        if (geometry.vertexDirtyId === thisAny.vertexDirty && thisAny._transformID === thisAny.transform._worldID)\r\n        {\r\n            return;\r\n        }\r\n\r\n        thisAny._transformID = thisAny.transform._worldID;\r\n\r\n        if (thisAny.vertexData.length !== vertices.length)\r\n        {\r\n            thisAny.vertexData = new Float32Array(vertices.length);\r\n        }\r\n\r\n        if (!this.vertexData2d || this.vertexData2d.length !== vertices.length * 3 / 2)\r\n        {\r\n            this.vertexData2d = new Float32Array(vertices.length * 3);\r\n        }\r\n\r\n        const wt = this.proj.world.mat3;\r\n\r\n        const vertexData2d = this.vertexData2d;\r\n        const vertexData = thisAny.vertexData;\r\n\r\n        for (let i = 0; i < vertexData.length / 2; i++)\r\n        {\r\n            const x = vertices[(i * 2)];\r\n            const y = vertices[(i * 2) + 1];\r\n\r\n            const xx = (wt[0] * x) + (wt[3] * y) + wt[6];\r\n            const yy = (wt[1] * x) + (wt[4] * y) + wt[7];\r\n            const ww = (wt[2] * x) + (wt[5] * y) + wt[8];\r\n\r\n            vertexData2d[i * 3] = xx;\r\n            vertexData2d[(i * 3) + 1] = yy;\r\n            vertexData2d[(i * 3) + 2] = ww;\r\n\r\n            vertexData[(i * 2)] = xx / ww;\r\n            vertexData[(i * 2) + 1] = yy / ww;\r\n        }\r\n\r\n        thisAny.vertexDirty = geometry.vertexDirtyId;\r\n    }\r\n\r\n    _renderDefault(renderer: Renderer): void\r\n    {\r\n        const shader = this.shader as MeshMaterial;\r\n\r\n        shader.alpha = this.worldAlpha;\r\n        if (shader.update)\r\n        {\r\n            shader.update();\r\n        }\r\n\r\n        renderer.batch.flush();\r\n\r\n        if ((shader as any).program.uniformData.translationMatrix)\r\n        {\r\n            shader.uniforms.translationMatrix = this.worldTransform.toArray(true);\r\n        }\r\n\r\n        // bind and sync uniforms..\r\n        renderer.shader.bind(shader, false);\r\n\r\n        // set state..\r\n        renderer.state.set(this.state);\r\n\r\n        // bind the geometry...\r\n        renderer.geometry.bind(this.geometry, shader);\r\n\r\n        // then render it\r\n        renderer.geometry.draw(this.drawMode, this.size, this.start, (this.geometry as any).instanceCount);\r\n    }\r\n\r\n    toLocal<T extends IPointData>(position: IPointData, from?: DisplayObject,\r\n        point?: T, skipUpdate?: boolean,\r\n        step = TRANSFORM_STEP.ALL): T\r\n    {\r\n        return container2dToLocal.call(this, position, from, point, skipUpdate, step);\r\n    }\r\n\r\n    get worldTransform(): Matrix\r\n    {\r\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\r\n    }\r\n}\r\n\r\nexport class SimpleMesh2d extends Mesh2d\r\n{\r\n    constructor(texture: Texture, vertices?: Float32Array, uvs?: Float32Array,\r\n        indices?: Uint16Array, drawMode?: number)\r\n    {\r\n        super(new MeshGeometry(vertices, uvs, indices),\r\n            new MeshMaterial(texture, {\r\n                program: Program.from(Mesh2d.defaultVertexShader, Mesh2d.defaultFragmentShader),\r\n                pluginName: 'batch2d'\r\n            }),\r\n            null,\r\n            drawMode);\r\n\r\n        (this.geometry.getBuffer('aVertexPosition') as any).static = false;\r\n    }\r\n\r\n    autoUpdate = true;\r\n\r\n    get vertices(): Float32Array\r\n    {\r\n        return this.geometry.getBuffer('aVertexPosition').data as Float32Array;\r\n    }\r\n    set vertices(value: Float32Array)\r\n    {\r\n        this.geometry.getBuffer('aVertexPosition').data = value;\r\n    }\r\n\r\n    protected _render(renderer?: Renderer): void\r\n    {\r\n        if (this.autoUpdate)\r\n        {\r\n            this.geometry.getBuffer('aVertexPosition').update();\r\n        }\r\n\r\n        (super._render as any)(renderer);\r\n    }\r\n}\r\n","/* eslint-disable no-mixed-operators */\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { Texture } from '@pixi/core';\r\nimport { Projection2d } from '../Projection2d';\r\nimport { IPointData, Matrix, Point } from '@pixi/math';\r\nimport { DisplayObject } from '@pixi/display';\r\nimport { TRANSFORM_STEP } from '../../base';\r\nimport { container2dToLocal } from '../Container2d';\r\n\r\nexport class Sprite2d extends Sprite\r\n{\r\n    constructor(texture: Texture)\r\n    {\r\n        super(texture);\r\n        this.proj = new Projection2d(this.transform);\r\n        this.pluginName = 'batch2d';\r\n    }\r\n\r\n    vertexData2d: Float32Array = null;\r\n    proj: Projection2d;\r\n\r\n    _calculateBounds(): void\r\n    {\r\n        this.calculateTrimmedVertices();\r\n        this._bounds.addQuad((this as any).vertexTrimmedData);\r\n    }\r\n\r\n    calculateVertices(): void\r\n    {\r\n        const texture = this._texture;\r\n        const thisAny = this as any;\r\n\r\n        if (this.proj._affine)\r\n        {\r\n            this.vertexData2d = null;\r\n            super.calculateVertices();\r\n\r\n            return;\r\n        }\r\n        if (!this.vertexData2d)\r\n        {\r\n            this.vertexData2d = new Float32Array(12);\r\n        }\r\n\r\n        const wid = (this.transform as any)._worldID;\r\n        const tuid = (texture as any)._updateID;\r\n\r\n        if (thisAny._transformID === wid && this._textureID === tuid)\r\n        {\r\n            return;\r\n        }\r\n        // update texture UV here, because base texture can be changed without calling `_onTextureUpdate`\r\n        if (this._textureID !== tuid)\r\n        {\r\n            (this as any).uvs = (texture as any)._uvs.uvsFloat32;\r\n        }\r\n\r\n        thisAny._transformID = wid;\r\n        this._textureID = tuid;\r\n\r\n        const wt = this.proj.world.mat3;\r\n        const vertexData2d = this.vertexData2d;\r\n        const vertexData = this.vertexData;\r\n        const trim = texture.trim;\r\n        const orig = texture.orig;\r\n        const anchor = this._anchor;\r\n\r\n        let w0: number;\r\n        let w1: number;\r\n        let h0: number;\r\n        let h1: number;\r\n\r\n        if (trim)\r\n        {\r\n            w1 = trim.x - (anchor._x * orig.width);\r\n            w0 = w1 + trim.width;\r\n\r\n            h1 = trim.y - (anchor._y * orig.height);\r\n            h0 = h1 + trim.height;\r\n        }\r\n        else\r\n        {\r\n            w1 = -anchor._x * orig.width;\r\n            w0 = w1 + orig.width;\r\n\r\n            h1 = -anchor._y * orig.height;\r\n            h0 = h1 + orig.height;\r\n        }\r\n\r\n        vertexData2d[0] = (wt[0] * w1) + (wt[3] * h1) + wt[6];\r\n        vertexData2d[1] = (wt[1] * w1) + (wt[4] * h1) + wt[7];\r\n        vertexData2d[2] = (wt[2] * w1) + (wt[5] * h1) + wt[8];\r\n\r\n        vertexData2d[3] = (wt[0] * w0) + (wt[3] * h1) + wt[6];\r\n        vertexData2d[4] = (wt[1] * w0) + (wt[4] * h1) + wt[7];\r\n        vertexData2d[5] = (wt[2] * w0) + (wt[5] * h1) + wt[8];\r\n\r\n        vertexData2d[6] = (wt[0] * w0) + (wt[3] * h0) + wt[6];\r\n        vertexData2d[7] = (wt[1] * w0) + (wt[4] * h0) + wt[7];\r\n        vertexData2d[8] = (wt[2] * w0) + (wt[5] * h0) + wt[8];\r\n\r\n        vertexData2d[9] = (wt[0] * w1) + (wt[3] * h0) + wt[6];\r\n        vertexData2d[10] = (wt[1] * w1) + (wt[4] * h0) + wt[7];\r\n        vertexData2d[11] = (wt[2] * w1) + (wt[5] * h0) + wt[8];\r\n\r\n        vertexData[0] = vertexData2d[0] / vertexData2d[2];\r\n        vertexData[1] = vertexData2d[1] / vertexData2d[2];\r\n\r\n        vertexData[2] = vertexData2d[3] / vertexData2d[5];\r\n        vertexData[3] = vertexData2d[4] / vertexData2d[5];\r\n\r\n        vertexData[4] = vertexData2d[6] / vertexData2d[8];\r\n        vertexData[5] = vertexData2d[7] / vertexData2d[8];\r\n\r\n        vertexData[6] = vertexData2d[9] / vertexData2d[11];\r\n        vertexData[7] = vertexData2d[10] / vertexData2d[11];\r\n    }\r\n\r\n    calculateTrimmedVertices(): void\r\n    {\r\n        if (this.proj._affine)\r\n        {\r\n            super.calculateTrimmedVertices();\r\n\r\n            return;\r\n        }\r\n\r\n        const wid = (this.transform as any)._worldID;\r\n        const tuid = (this._texture as any)._updateID;\r\n        const thisAny = this as any;\r\n\r\n        if (!thisAny.vertexTrimmedData)\r\n        {\r\n            thisAny.vertexTrimmedData = new Float32Array(8);\r\n        }\r\n        else if (thisAny._transformTrimmedID === wid && this._textureTrimmedID === tuid)\r\n        {\r\n            return;\r\n        }\r\n\r\n        thisAny._transformTrimmedID = wid;\r\n        this._textureTrimmedID = tuid;\r\n\r\n        // lets do some special trim code!\r\n        const texture = this._texture;\r\n        const vertexData = thisAny.vertexTrimmedData;\r\n        const orig = texture.orig;\r\n        const w = (this as any).tileProj ? this._width : orig.width;\r\n        const h = (this as any).tileProj ? this._height : orig.height;\r\n        const anchor = this._anchor;\r\n\r\n        // lets calculate the new untrimmed bounds..\r\n        const wt = this.proj.world.mat3;\r\n\r\n        const w1 = -anchor._x * w;\r\n        const w0 = w1 + w;\r\n\r\n        const h1 = -anchor._y * h;\r\n        const h0 = h1 + h;\r\n\r\n        let z = 1.0 / (wt[2] * w1 + wt[5] * h1 + wt[8]);\r\n\r\n        vertexData[0] = z * ((wt[0] * w1) + (wt[3] * h1) + wt[6]);\r\n        vertexData[1] = z * ((wt[1] * w1) + (wt[4] * h1) + wt[7]);\r\n\r\n        z = 1.0 / (wt[2] * w0 + wt[5] * h1 + wt[8]);\r\n        vertexData[2] = z * ((wt[0] * w0) + (wt[3] * h1) + wt[6]);\r\n        vertexData[3] = z * ((wt[1] * w0) + (wt[4] * h1) + wt[7]);\r\n\r\n        z = 1.0 / (wt[2] * w0 + wt[5] * h0 + wt[8]);\r\n        vertexData[4] = z * ((wt[0] * w0) + (wt[3] * h0) + wt[6]);\r\n        vertexData[5] = z * ((wt[1] * w0) + (wt[4] * h0) + wt[7]);\r\n\r\n        z = 1.0 / (wt[2] * w1 + wt[5] * h0 + wt[8]);\r\n        vertexData[6] = z * ((wt[0] * w1) + (wt[3] * h0) + wt[6]);\r\n        vertexData[7] = z * ((wt[1] * w1) + (wt[4] * h0) + wt[7]);\r\n    }\r\n\r\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean,\r\n        step = TRANSFORM_STEP.ALL): P\r\n    {\r\n        return container2dToLocal.call(this, position, from, point, skipUpdate, step);\r\n    }\r\n\r\n    get worldTransform(): Matrix\r\n    {\r\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\r\n    }\r\n}\r\n","import { Renderer, Texture } from '@pixi/core';\r\nimport { IPointData, Matrix, Point, Transform } from '@pixi/math';\r\nimport { Projection2d } from '../Projection2d';\r\nimport { DisplayObject } from '@pixi/display';\r\nimport { TRANSFORM_STEP } from '../../base';\r\nimport { container2dToLocal } from '../Container2d';\r\nimport { TilingSprite } from '@pixi/sprite-tiling';\r\n\r\nconst tempTransform = new Transform();\r\n\r\nexport class TilingSprite2d extends TilingSprite\r\n{\r\n    constructor(texture: Texture, width: number, height: number)\r\n    {\r\n        super(texture, width, height);\r\n\r\n        this.tileProj = new Projection2d(this.tileTransform);\r\n        this.tileProj.reverseLocalOrder = true;\r\n        this.proj = new Projection2d(this.transform);\r\n\r\n        this.pluginName = 'tilingSprite2d';\r\n        this.uvRespectAnchor = true;\r\n    }\r\n\r\n    tileProj: Projection2d;\r\n    proj: Projection2d;\r\n\r\n    get worldTransform(): Matrix\r\n    {\r\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\r\n    }\r\n\r\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean,\r\n        step = TRANSFORM_STEP.ALL): P\r\n    {\r\n        return container2dToLocal.call(this, position, from, point, skipUpdate, step);\r\n    }\r\n\r\n    _render(renderer: Renderer): void\r\n    {\r\n        // tweak our texture temporarily..\r\n        const texture = this._texture;\r\n\r\n        if (!texture || !texture.valid)\r\n        {\r\n            return;\r\n        }\r\n\r\n        // changed\r\n        this.tileTransform.updateTransform(tempTransform);\r\n        this.uvMatrix.update();\r\n\r\n        renderer.batch.setObjectRenderer((renderer.plugins as any)[this.pluginName]);\r\n        (renderer.plugins as any)[this.pluginName].render(this);\r\n    }\r\n}\r\n","import { Projection2d } from '../Projection2d';\r\nimport { Container2d, container2dWorldTransform } from '../Container2d';\r\nimport { TilingSprite } from '@pixi/sprite-tiling';\r\nimport { Program } from '@pixi/core';\r\nimport { MeshMaterial } from '@pixi/mesh';\r\nimport { Mesh2d } from '../mesh/Mesh2d';\r\nimport { SimpleMesh, SimpleRope } from '@pixi/mesh-extras';\r\nimport { Container } from '@pixi/display';\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { Sprite2d } from './Sprite2d';\r\nimport { TilingSprite2d } from '../tiling/TilingSprite2d';\r\n\r\nfunction convertTo2d()\r\n{\r\n    if (this.proj) return;\r\n    this.proj = new Projection2d(this.transform);\r\n    this.toLocal = Container2d.prototype.toLocal;\r\n    Object.defineProperty(this, 'worldTransform', {\r\n        get: container2dWorldTransform,\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n}\r\n\r\nContainer.prototype.convertTo2d = convertTo2d;\r\n\r\nSprite.prototype.convertTo2d = function spriteConvertTo2d()\r\n{\r\n    if (this.proj) return;\r\n    this.calculateVertices = Sprite2d.prototype.calculateVertices;\r\n    this.calculateTrimmedVertices = Sprite2d.prototype.calculateTrimmedVertices;\r\n    this._calculateBounds = Sprite2d.prototype._calculateBounds;\r\n    this.pluginName = 'batch2d';\r\n    convertTo2d.call(this);\r\n};\r\n\r\nContainer.prototype.convertSubtreeTo2d = function convertSubtreeTo2d()\r\n{\r\n    this.convertTo2d();\r\n    for (let i = 0; i < this.children.length; i++)\r\n    {\r\n        this.children[i].convertSubtreeTo2d();\r\n    }\r\n};\r\n\r\nSimpleMesh.prototype.convertTo2d\r\n    = SimpleRope.prototype.convertTo2d\r\n        = function meshConvertTo2d()\r\n        {\r\n            if (this.proj) return;\r\n            this.calculateVertices = Mesh2d.prototype.calculateVertices;\r\n            this._renderDefault = Mesh2d.prototype._renderDefault;\r\n            if (this.material.pluginName !== 'batch2d')\r\n            {\r\n                this.material = new MeshMaterial(this.material.texture, {\r\n                    program: Program.from(Mesh2d.defaultVertexShader, Mesh2d.defaultFragmentShader),\r\n                    pluginName: 'batch2d'\r\n                });\r\n            }\r\n            convertTo2d.call(this);\r\n        };\r\n\r\nTilingSprite.prototype.convertTo2d = function tilingConvertTo2d()\r\n{\r\n    if (this.proj) return;\r\n\r\n    this.tileProj = new Projection2d(this.tileTransform);\r\n    this.tileProj.reverseLocalOrder = true;\r\n    this.uvRespectAnchor = true;\r\n\r\n    this.calculateTrimmedVertices = Sprite2d.prototype.calculateTrimmedVertices;\r\n    this._calculateBounds = Sprite2d.prototype._calculateBounds;\r\n    this._render = TilingSprite2d.prototype._render;\r\n\r\n    this.pluginName = 'tilingSprite2d';\r\n    convertTo2d.call(this);\r\n};\r\n","import { Text, TextStyle } from '@pixi/text';\r\nimport { Projection2d } from '../Projection2d';\r\nimport { Sprite2d } from './Sprite2d';\r\nimport { Matrix } from '@pixi/math';\r\n\r\nexport class Text2d extends Text\r\n{\r\n    constructor(text?: string, style?: TextStyle, canvas?: HTMLCanvasElement)\r\n    {\r\n        super(text, style, canvas);\r\n        this.proj = new Projection2d(this.transform);\r\n        this.pluginName = 'batch2d';\r\n    }\r\n\r\n    proj: Projection2d;\r\n    vertexData2d: Float32Array = null;\r\n\r\n    get worldTransform(): Matrix\r\n    {\r\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\r\n    }\r\n}\r\n\r\nText2d.prototype.calculateVertices = Sprite2d.prototype.calculateVertices;\r\nText2d.prototype.calculateTrimmedVertices = Sprite2d.prototype.calculateTrimmedVertices;\r\n(Text2d.prototype as any)._calculateBounds = Sprite2d.prototype._calculateBounds;\r\n","import { Sprite } from '@pixi/sprite';\r\nimport { Matrix2d } from '../Matrix2d';\r\nimport { Filter, FilterSystem, RenderTexture, TextureMatrix } from '@pixi/core';\r\nimport { Projection2d } from '../Projection2d';\r\n\r\nconst spriteMaskVert = `\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 otherMatrix;\r\n\r\nvarying vec3 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\ngl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\nvTextureCoord = aTextureCoord;\r\nvMaskCoord = otherMatrix * vec3( aTextureCoord, 1.0);\r\n}\r\n`;\r\nconst spriteMaskFrag = `\r\nvarying vec3 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform sampler2D mask;\r\nuniform float alpha;\r\nuniform vec4 maskClamp;\r\n\r\nvoid main(void)\r\n{\r\nvec2 uv = vMaskCoord.xy / vMaskCoord.z;\r\n\r\nfloat clip = step(3.5,\r\n    step(maskClamp.x, uv.x) +\r\n    step(maskClamp.y, uv.y) +\r\n    step(uv.x, maskClamp.z) +\r\n    step(uv.y, maskClamp.w));\r\n\r\nvec4 original = texture2D(uSampler, vTextureCoord);\r\nvec4 masky = texture2D(mask, uv);\r\n\r\noriginal *= (masky.r * masky.a * alpha * clip);\r\n\r\ngl_FragColor = original;\r\n}\r\n`;\r\n\r\nconst tempMat = new Matrix2d();\r\n\r\nexport class SpriteMaskFilter2d extends Filter\r\n{\r\n    constructor(sprite: Sprite)\r\n    {\r\n        super(spriteMaskVert, spriteMaskFrag);\r\n\r\n        sprite.renderable = false;\r\n\r\n        this.maskSprite = sprite;\r\n    }\r\n\r\n    maskSprite: Sprite;\r\n    maskMatrix = new Matrix2d();\r\n\r\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture,\r\n        clearMode?: number): void\r\n    {\r\n        const maskSprite = this.maskSprite;\r\n        const tex = this.maskSprite.texture;\r\n\r\n        if (!tex.valid)\r\n        {\r\n            return;\r\n        }\r\n        if (!tex.uvMatrix)\r\n        {\r\n            // margin = 0.0, let it bleed a bit, shader code becomes easier\r\n            // assuming that atlas textures were made with 1-pixel padding\r\n            tex.uvMatrix = new TextureMatrix(tex, 0.0);\r\n        }\r\n        tex.uvMatrix.update();\r\n\r\n        this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0.0 : 1.0;\r\n        this.uniforms.mask = maskSprite.texture;\r\n        this.uniforms.otherMatrix = SpriteMaskFilter2d.calculateSpriteMatrix(input, this.maskMatrix, maskSprite)\r\n            .prepend(tex.uvMatrix.mapCoord);\r\n        this.uniforms.alpha = maskSprite.worldAlpha;\r\n        this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;\r\n\r\n        filterManager.applyFilter(this, input, output, clearMode);\r\n    }\r\n\r\n    static calculateSpriteMatrix(input: RenderTexture, mappedMatrix: Matrix2d, sprite: Sprite): Matrix2d\r\n    {\r\n        const proj = (sprite as any).proj as Projection2d;\r\n\r\n        const filterArea = (input as any).filterFrame;\r\n\r\n        // eslint-disable-next-line max-len\r\n        const worldTransform = proj && !proj._affine ? proj.world.copyTo2dOr3d(tempMat) : tempMat.copyFrom(sprite.transform.worldTransform);\r\n        const texture = sprite.texture.orig;\r\n\r\n        mappedMatrix.set(input.width, 0, 0, input.height, filterArea.x, filterArea.y);\r\n        worldTransform.invert();\r\n        mappedMatrix.setToMult(worldTransform, mappedMatrix);\r\n        mappedMatrix.scaleAndTranslate(1.0 / texture.width, 1.0 / texture.height,\r\n            sprite.anchor.x, sprite.anchor.y);\r\n\r\n        return mappedMatrix;\r\n    }\r\n}\r\n","import { MaskData, MaskSystem } from '@pixi/core';\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { SpriteMaskFilter2d } from './SpriteMaskFilter';\r\n\r\nMaskSystem.prototype.pushSpriteMask = function pushSpriteMask(maskData: MaskData): void\r\n{\r\n    const { maskObject } = maskData;\r\n    const target = (maskData as any)._target;\r\n\r\n    let alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];\r\n\r\n    if (!alphaMaskFilter)\r\n    {\r\n        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter2d(maskObject as Sprite)];\r\n    }\r\n\r\n    alphaMaskFilter[0].resolution = this.renderer.resolution;\r\n    alphaMaskFilter[0].maskSprite = maskObject;\r\n\r\n    const stashFilterArea = target.filterArea;\r\n\r\n    target.filterArea = maskObject.getBounds(true);\r\n    this.renderer.filter.push(target, alphaMaskFilter);\r\n    target.filterArea = stashFilterArea;\r\n\r\n    this.alphaMaskIndex++;\r\n};\r\n","import { Renderer } from '@pixi/core';\r\nimport { TilingSprite2dRenderer } from './tiling/TilingSprite2dRenderer';\r\n\r\nexport * from './Matrix2d';\r\nexport * from './Projection2d';\r\nexport * from './Container2d';\r\n\r\nexport * from './sprites/convert';\r\nexport * from './sprites/Sprite2d';\r\nexport * from './sprites/Text2d';\r\n\r\nexport * from './tiling/TilingSprite2d';\r\nexport * from './tiling/TilingSprite2dRenderer';\r\n\r\nexport * from './z_masks/MaskHacker';\r\nexport * from './z_masks/SpriteMaskFilter';\r\n\r\nexport * from './mesh/Mesh2d';\r\n\r\nRenderer.registerPlugin('tilingSprite2d', TilingSprite2dRenderer as any);\r\n","import { IPoint, IPointData, ObservablePoint, Point } from '@pixi/math';\r\n\r\nexport class Point3d extends Point\r\n{\r\n    // TODO: pixi 6.1.0 global mixin\r\n    z: number;\r\n    constructor(x?: number, y?: number, z?: number)\r\n    {\r\n        super(x, y);\r\n        this.z = z;\r\n    }\r\n\r\n    set(x?: number, y?: number, z?: number): this\r\n    {\r\n        this.x = x || 0;\r\n        this.y = (y === undefined) ? this.x : (y || 0);\r\n        this.z = (y === undefined) ? this.x : (z || 0);\r\n\r\n        return this;\r\n    }\r\n\r\n    copyFrom(p: IPointData): this\r\n    {\r\n        // TODO: pixi 6.1.0 global mixin\r\n        this.set(p.x, p.y, (p as any).z || 0);\r\n\r\n        return this;\r\n    }\r\n\r\n    copyTo<T extends IPoint>(p: T): T\r\n    {\r\n        (p as any).set(this.x, this.y, this.z);\r\n\r\n        return p;\r\n    }\r\n}\r\n\r\nexport class ObservablePoint3d extends ObservablePoint\r\n{\r\n    _z = 0;\r\n\r\n    get z(): number\r\n    {\r\n        return this._z;\r\n    }\r\n\r\n    set z(value: number)\r\n    {\r\n        if (this._z !== value)\r\n        {\r\n            this._z = value;\r\n            this.cb.call(this.scope);\r\n        }\r\n    }\r\n\r\n    set(x?: number, y?: number, z?: number): this\r\n    {\r\n        const _x = x || 0;\r\n        const _y = (y === undefined) ? _x : (y || 0);\r\n        const _z = (y === undefined) ? _x : (z || 0);\r\n\r\n        if (this._x !== _x || this._y !== _y || this._z !== _z)\r\n        {\r\n            this._x = _x;\r\n            this._y = _y;\r\n            this._z = _z;\r\n            this.cb.call(this.scope);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    copyFrom(p: IPointData): this\r\n    {\r\n        // TODO: pixi 6.1.0 global mixin\r\n        this.set(p.x, p.y, (p as any).z || 0);\r\n\r\n        return this;\r\n    }\r\n\r\n    copyTo<T extends IPoint>(p: T): T\r\n    {\r\n        (p as any).set(this._x, this._y, this._z);\r\n\r\n        return p;\r\n    }\r\n}\r\n","import { IEuler } from './ObservableEuler';\r\n\r\nexport class Euler\r\n{\r\n    constructor(x?: number, y?: number, z?: number)\r\n    {\r\n        /**\r\n         * @member {number}\r\n         * @default 0\r\n         */\r\n        this._x = x || 0;\r\n\r\n        /**\r\n         * @member {number}\r\n         * @default 0\r\n         */\r\n        this._y = y || 0;\r\n\r\n        /**\r\n         * @member {number}\r\n         * @default 0\r\n         */\r\n        this._z = z || 0;\r\n\r\n        this.quaternion = new Float64Array(4);\r\n        this.quaternion[3] = 1;\r\n\r\n        this.update();\r\n    }\r\n\r\n    _quatUpdateId = -1;\r\n    _quatDirtyId = 0;\r\n\r\n    quaternion: Float64Array;\r\n\r\n    _x: number;\r\n    _y: number;\r\n    _z: number;\r\n    _sign = 1;\r\n\r\n    get x(): number\r\n    {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: number)\r\n    {\r\n        if (this._x !== value)\r\n        {\r\n            this._x = value;\r\n            this._quatDirtyId++;\r\n        }\r\n    }\r\n\r\n    get y(): number\r\n    {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: number)\r\n    {\r\n        if (this._y !== value)\r\n        {\r\n            this._y = value;\r\n            this._quatDirtyId++;\r\n        }\r\n    }\r\n\r\n    get z(): number\r\n    {\r\n        return this._z;\r\n    }\r\n\r\n    set z(value: number)\r\n    {\r\n        if (this._z !== value)\r\n        {\r\n            this._z = value;\r\n            this._quatDirtyId++;\r\n        }\r\n    }\r\n\r\n    get pitch(): number\r\n    {\r\n        return this._x;\r\n    }\r\n\r\n    set pitch(value: number)\r\n    {\r\n        if (this._x !== value)\r\n        {\r\n            this._x = value;\r\n            this._quatDirtyId++;\r\n        }\r\n    }\r\n\r\n    get yaw(): number\r\n    {\r\n        return this._y;\r\n    }\r\n\r\n    set yaw(value: number)\r\n    {\r\n        if (this._y !== value)\r\n        {\r\n            this._y = value;\r\n            this._quatDirtyId++;\r\n        }\r\n    }\r\n\r\n    get roll(): number\r\n    {\r\n        return this._z;\r\n    }\r\n\r\n    set roll(value: number)\r\n    {\r\n        if (this._z !== value)\r\n        {\r\n            this._z = value;\r\n            this._quatDirtyId++;\r\n        }\r\n    }\r\n\r\n    set(x?: number, y?: number, z?: number): void\r\n    {\r\n        const _x = x || 0;\r\n        const _y = y || 0;\r\n        const _z = z || 0;\r\n\r\n        if (this._x !== _x || this._y !== _y || this._z !== _z)\r\n        {\r\n            this._x = _x;\r\n            this._y = _y;\r\n            this._z = _z;\r\n            this._quatDirtyId++;\r\n        }\r\n    }\r\n\r\n    copyFrom(euler: IEuler): this\r\n    {\r\n        const _x = euler.x;\r\n        const _y = euler.y;\r\n        const _z = euler.z;\r\n\r\n        if (this._x !== _x || this._y !== _y || this._z !== _z)\r\n        {\r\n            this._x = _x;\r\n            this._y = _y;\r\n            this._z = _z;\r\n            this._quatDirtyId++;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    copyTo(p: IEuler): IEuler\r\n    {\r\n        p.set(this._x, this._y, this._z);\r\n\r\n        return p;\r\n    }\r\n\r\n    equals(euler: IEuler): boolean\r\n    {\r\n        return this._x === euler.x\r\n            && this._y === euler.y\r\n            && this._z === euler.z;\r\n    }\r\n\r\n    clone(): Euler\r\n    {\r\n        return new Euler(this._x, this._y, this._z);\r\n    }\r\n\r\n    update(): boolean\r\n    {\r\n        if (this._quatUpdateId === this._quatDirtyId)\r\n        {\r\n            return false;\r\n        }\r\n        this._quatUpdateId = this._quatDirtyId;\r\n\r\n        const c1 = Math.cos(this._x / 2);\r\n        const c2 = Math.cos(this._y / 2);\r\n        const c3 = Math.cos(this._z / 2);\r\n\r\n        const s = this._sign;\r\n        const s1 = s * Math.sin(this._x / 2);\r\n        const s2 = s * Math.sin(this._y / 2);\r\n        const s3 = s * Math.sin(this._z / 2);\r\n\r\n        const q = this.quaternion;\r\n\r\n        q[0] = (s1 * c2 * c3) + (c1 * s2 * s3);\r\n        q[1] = (c1 * s2 * c3) - (s1 * c2 * s3);\r\n        q[2] = (c1 * c2 * s3) + (s1 * s2 * c3);\r\n        q[3] = (c1 * c2 * c3) - (s1 * s2 * s3);\r\n\r\n        return true;\r\n    }\r\n}\r\n","import { Euler } from './Euler';\r\n\r\nexport type IEuler = Euler | ObservableEuler;\r\n\r\n/**\r\n * The Euler angles, order is YZX. Except for projections (camera.lookEuler), its reversed XZY\r\n * @class\r\n * @namespace PIXI.projection\r\n * @param x pitch\r\n * @param y yaw\r\n * @param z roll\r\n * @constructor\r\n */\r\n\r\nexport class ObservableEuler\r\n{\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    constructor(public cb: any, public scope: any, x?: number, y?: number, z?: number)\r\n    {\r\n        /**\r\n         * @member {number}\r\n         * @default 0\r\n         */\r\n        this._x = x || 0;\r\n\r\n        /**\r\n         * @member {number}\r\n         * @default 0\r\n         */\r\n        this._y = y || 0;\r\n\r\n        /**\r\n         * @member {number}\r\n         * @default 0\r\n         */\r\n        this._z = z || 0;\r\n\r\n        this.quaternion = new Float64Array(4);\r\n        this.quaternion[3] = 1;\r\n\r\n        this.update();\r\n    }\r\n\r\n    _quatUpdateId = -1;\r\n    _quatDirtyId = 0;\r\n\r\n    quaternion: Float64Array;\r\n\r\n    _x: number;\r\n    _y: number;\r\n    _z: number;\r\n    _sign = 1;\r\n\r\n    get x(): number\r\n    {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: number)\r\n    {\r\n        if (this._x !== value)\r\n        {\r\n            this._x = value;\r\n            this._quatDirtyId++;\r\n            this.cb.call(this.scope);\r\n        }\r\n    }\r\n\r\n    get y(): number\r\n    {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: number)\r\n    {\r\n        if (this._y !== value)\r\n        {\r\n            this._y = value;\r\n            this._quatDirtyId++;\r\n            this.cb.call(this.scope);\r\n        }\r\n    }\r\n\r\n    get z(): number\r\n    {\r\n        return this._z;\r\n    }\r\n\r\n    set z(value: number)\r\n    {\r\n        if (this._z !== value)\r\n        {\r\n            this._z = value;\r\n            this._quatDirtyId++;\r\n            this.cb.call(this.scope);\r\n        }\r\n    }\r\n\r\n    get pitch(): number\r\n    {\r\n        return this._x;\r\n    }\r\n\r\n    set pitch(value: number)\r\n    {\r\n        if (this._x !== value)\r\n        {\r\n            this._x = value;\r\n            this._quatDirtyId++;\r\n            this.cb.call(this.scope);\r\n        }\r\n    }\r\n\r\n    get yaw(): number\r\n    {\r\n        return this._y;\r\n    }\r\n\r\n    set yaw(value: number)\r\n    {\r\n        if (this._y !== value)\r\n        {\r\n            this._y = value;\r\n            this._quatDirtyId++;\r\n            this.cb.call(this.scope);\r\n        }\r\n    }\r\n\r\n    get roll(): number\r\n    {\r\n        return this._z;\r\n    }\r\n\r\n    set roll(value: number)\r\n    {\r\n        if (this._z !== value)\r\n        {\r\n            this._z = value;\r\n            this._quatDirtyId++;\r\n            this.cb.call(this.scope);\r\n        }\r\n    }\r\n\r\n    set(x?: number, y?: number, z?: number): this\r\n    {\r\n        const _x = x || 0;\r\n        const _y = y || 0;\r\n        const _z = z || 0;\r\n\r\n        if (this._x !== _x || this._y !== _y || this._z !== _z)\r\n        {\r\n            this._x = _x;\r\n            this._y = _y;\r\n            this._z = _z;\r\n            this._quatDirtyId++;\r\n            this.cb.call(this.scope);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    copyFrom(euler: IEuler): this\r\n    {\r\n        const _x = euler.x;\r\n        const _y = euler.y;\r\n        const _z = euler.z;\r\n\r\n        if (this._x !== _x || this._y !== _y || this._z !== _z)\r\n        {\r\n            this._x = _x;\r\n            this._y = _y;\r\n            this._z = _z;\r\n            this._quatDirtyId++;\r\n            this.cb.call(this.scope);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    copyTo(p: IEuler): IEuler\r\n    {\r\n        p.set(this._x, this._y, this._z);\r\n\r\n        return p;\r\n    }\r\n\r\n    equals(euler: IEuler): boolean\r\n    {\r\n        return this._x === euler.x\r\n            && this._y === euler.y\r\n            && this._z === euler.z;\r\n    }\r\n\r\n    clone(): Euler\r\n    {\r\n        return new Euler(this._x, this._y, this._z);\r\n    }\r\n\r\n    update(): boolean\r\n    {\r\n        if (this._quatUpdateId === this._quatDirtyId)\r\n        {\r\n            return false;\r\n        }\r\n        this._quatUpdateId = this._quatDirtyId;\r\n\r\n        const c1 = Math.cos(this._x / 2);\r\n        const c2 = Math.cos(this._y / 2);\r\n        const c3 = Math.cos(this._z / 2);\r\n\r\n        const s = this._sign;\r\n        const s1 = s * Math.sin(this._x / 2);\r\n        const s2 = s * Math.sin(this._y / 2);\r\n        const s3 = s * Math.sin(this._z / 2);\r\n\r\n        const q = this.quaternion;\r\n\r\n        q[0] = (s1 * c2 * c3) + (c1 * s2 * s3);\r\n        q[1] = (c1 * s2 * c3) - (s1 * c2 * s3);\r\n        q[2] = (c1 * c2 * s3) + (s1 * s2 * c3);\r\n        q[3] = (c1 * c2 * c3) - (s1 * s2 * s3);\r\n\r\n        return true;\r\n    }\r\n}\r\n","/* eslint-disable no-mixed-operators,max-statements-per-line */\r\n// according to https://jsperf.com/obj-vs-array-view-access/1 , Float64Array is the best here\r\n\r\nimport { IPointData, Matrix, Point } from '@pixi/math';\r\nimport { Matrix2d } from '../proj2d';\r\nimport { Point3d } from './Point3d';\r\nimport { AFFINE } from '../base';\r\n\r\nconst mat4id = [1, 0, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 0, 1];\r\n\r\nexport class Matrix3d\r\n{\r\n    /**\r\n     * A default (identity) matrix\r\n     *\r\n     * @static\r\n     * @const\r\n     */\r\n    static readonly IDENTITY = new Matrix3d();\r\n\r\n    /**\r\n     * A temp matrix\r\n     *\r\n     * @static\r\n     * @const\r\n     */\r\n    static readonly TEMP_MATRIX = new Matrix3d();\r\n\r\n    /**\r\n     * mat4 implementation through array of 16 elements\r\n     */\r\n    mat4: Float64Array;\r\n\r\n    floatArray: Float32Array = null;\r\n\r\n    _dirtyId = 0;\r\n    _updateId = -1;\r\n    _mat4inv: Float64Array = null;\r\n    cacheInverse = false;\r\n\r\n    constructor(backingArray?: ArrayLike<number>)\r\n    {\r\n        this.mat4 = new Float64Array(backingArray || mat4id);\r\n    }\r\n\r\n    get a(): number\r\n    {\r\n        return this.mat4[0] / this.mat4[15];\r\n    }\r\n\r\n    set a(value: number)\r\n    {\r\n        this.mat4[0] = value * this.mat4[15];\r\n    }\r\n\r\n    get b(): number\r\n    {\r\n        return this.mat4[1] / this.mat4[15];\r\n    }\r\n\r\n    set b(value: number)\r\n    {\r\n        this.mat4[1] = value * this.mat4[15];\r\n    }\r\n\r\n    get c(): number\r\n    {\r\n        return this.mat4[4] / this.mat4[15];\r\n    }\r\n\r\n    set c(value: number)\r\n    {\r\n        this.mat4[4] = value * this.mat4[15];\r\n    }\r\n\r\n    get d(): number\r\n    {\r\n        return this.mat4[5] / this.mat4[15];\r\n    }\r\n\r\n    set d(value: number)\r\n    {\r\n        this.mat4[5] = value * this.mat4[15];\r\n    }\r\n\r\n    get tx(): number\r\n    {\r\n        return this.mat4[12] / this.mat4[15];\r\n    }\r\n\r\n    set tx(value: number)\r\n    {\r\n        this.mat4[12] = value * this.mat4[15];\r\n    }\r\n\r\n    get ty(): number\r\n    {\r\n        return this.mat4[13] / this.mat4[15];\r\n    }\r\n\r\n    set ty(value: number)\r\n    {\r\n        this.mat4[13] = value * this.mat4[15];\r\n    }\r\n\r\n    set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\r\n    {\r\n        const mat4 = this.mat4;\r\n\r\n        mat4[0] = a;\r\n        mat4[1] = b;\r\n        mat4[2] = 0;\r\n        mat4[3] = 0;\r\n        mat4[4] = c;\r\n        mat4[5] = d;\r\n        mat4[6] = 0;\r\n        mat4[7] = 0;\r\n        mat4[8] = 0;\r\n        mat4[9] = 0;\r\n        mat4[10] = 1;\r\n        mat4[11] = 0;\r\n        mat4[12] = tx;\r\n        mat4[13] = ty;\r\n        mat4[14] = 0;\r\n        mat4[15] = 1;\r\n\r\n        return this;\r\n    }\r\n\r\n    toArray(transpose?: boolean, out?: Float32Array): Float32Array\r\n    {\r\n        if (!this.floatArray)\r\n        {\r\n            this.floatArray = new Float32Array(9);\r\n        }\r\n\r\n        const array = out || this.floatArray;\r\n        const mat3 = this.mat4;\r\n\r\n        if (transpose)\r\n        {\r\n            array[0] = mat3[0];\r\n            array[1] = mat3[1];\r\n            array[2] = mat3[3];\r\n            array[3] = mat3[4];\r\n            array[4] = mat3[5];\r\n            array[5] = mat3[7];\r\n            array[6] = mat3[12];\r\n            array[7] = mat3[13];\r\n            array[8] = mat3[15];\r\n        }\r\n        else\r\n        {\r\n            // this branch is NEVER USED in pixi\r\n            array[0] = mat3[0];\r\n            array[1] = mat3[4];\r\n            array[2] = mat3[12];\r\n            array[3] = mat3[2];\r\n            array[4] = mat3[6];\r\n            array[5] = mat3[13];\r\n            array[6] = mat3[3];\r\n            array[7] = mat3[7];\r\n            array[8] = mat3[15];\r\n        }\r\n\r\n        return array;\r\n    }\r\n\r\n    setToTranslation(tx: number, ty: number, tz: number): void\r\n    {\r\n        const mat4 = this.mat4;\r\n\r\n        mat4[0] = 1;\r\n        mat4[1] = 0;\r\n        mat4[2] = 0;\r\n        mat4[3] = 0;\r\n\r\n        mat4[4] = 0;\r\n        mat4[5] = 1;\r\n        mat4[6] = 0;\r\n        mat4[7] = 0;\r\n\r\n        mat4[8] = 0;\r\n        mat4[9] = 0;\r\n        mat4[10] = 1;\r\n        mat4[11] = 0;\r\n\r\n        mat4[12] = tx;\r\n        mat4[13] = ty;\r\n        mat4[14] = tz;\r\n        mat4[15] = 1;\r\n    }\r\n\r\n    // eslint-disable-next-line max-len\r\n    setToRotationTranslationScale(quat: Float64Array, tx: number, ty: number, tz: number, sx: number, sy: number, sz: number): Float64Array\r\n    {\r\n        const out = this.mat4;\r\n\r\n        const x = quat[0]; const y = quat[1]; const z = quat[2]; const\r\n            w = quat[3];\r\n        const x2 = x + x;\r\n        const y2 = y + y;\r\n        const z2 = z + z;\r\n\r\n        const xx = x * x2;\r\n        const xy = x * y2;\r\n        const xz = x * z2;\r\n        const yy = y * y2;\r\n        const yz = y * z2;\r\n        const zz = z * z2;\r\n        const wx = w * x2;\r\n        const wy = w * y2;\r\n        const wz = w * z2;\r\n\r\n        out[0] = (1 - (yy + zz)) * sx;\r\n        out[1] = (xy + wz) * sx;\r\n        out[2] = (xz - wy) * sx;\r\n        out[3] = 0;\r\n        out[4] = (xy - wz) * sy;\r\n        out[5] = (1 - (xx + zz)) * sy;\r\n        out[6] = (yz + wx) * sy;\r\n        out[7] = 0;\r\n        out[8] = (xz + wy) * sz;\r\n        out[9] = (yz - wx) * sz;\r\n        out[10] = (1 - (xx + yy)) * sz;\r\n        out[11] = 0;\r\n        out[12] = tx;\r\n        out[13] = ty;\r\n        out[14] = tz;\r\n        out[15] = 1;\r\n\r\n        return out;\r\n    }\r\n\r\n    apply(pos: IPointData, newPos: IPointData): IPointData\r\n    {\r\n        newPos = newPos || new Point3d();\r\n\r\n        const mat4 = this.mat4;\r\n        const x = pos.x;\r\n        const y = pos.y;\r\n        // TODO: pixi 6.1.0 global mixin\r\n        const z = (pos as any).z || 0;\r\n\r\n        // TODO: apply for 2d point\r\n\r\n        const w = 1.0 / (mat4[3] * x + mat4[7] * y + mat4[11] * z + mat4[15]);\r\n\r\n        newPos.x = w * (mat4[0] * x + mat4[4] * y + mat4[8] * z + mat4[12]);\r\n        newPos.y = w * (mat4[1] * x + mat4[5] * y + mat4[9] * z + mat4[13]);\r\n        // TODO: pixi 6.1.0 global mixin\r\n        (newPos as any).z = w * (mat4[2] * x + mat4[6] * y + mat4[10] * z + mat4[14]);\r\n\r\n        return newPos;\r\n    }\r\n\r\n    translate(tx: number, ty: number, tz: number): this\r\n    {\r\n        const a = this.mat4;\r\n\r\n        a[12] = a[0] * tx + a[4] * ty + a[8] * tz + a[12];\r\n        a[13] = a[1] * tx + a[5] * ty + a[9] * tz + a[13];\r\n        a[14] = a[2] * tx + a[6] * ty + a[10] * tz + a[14];\r\n        a[15] = a[3] * tx + a[7] * ty + a[11] * tz + a[15];\r\n\r\n        return this;\r\n    }\r\n\r\n    scale(x: number, y: number, z?: number): this\r\n    {\r\n        const mat4 = this.mat4;\r\n\r\n        mat4[0] *= x;\r\n        mat4[1] *= x;\r\n        mat4[2] *= x;\r\n        mat4[3] *= x;\r\n\r\n        mat4[4] *= y;\r\n        mat4[5] *= y;\r\n        mat4[6] *= y;\r\n        mat4[7] *= y;\r\n\r\n        if (z !== undefined)\r\n        {\r\n            mat4[8] *= z;\r\n            mat4[9] *= z;\r\n            mat4[10] *= z;\r\n            mat4[11] *= z;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    scaleAndTranslate(scaleX: number, scaleY: number, scaleZ: number, tx: number, ty: number, tz: number): void\r\n    {\r\n        const mat4 = this.mat4;\r\n\r\n        mat4[0] = scaleX * mat4[0] + tx * mat4[3];\r\n        mat4[1] = scaleY * mat4[1] + ty * mat4[3];\r\n        mat4[2] = scaleZ * mat4[2] + tz * mat4[3];\r\n\r\n        mat4[4] = scaleX * mat4[4] + tx * mat4[7];\r\n        mat4[5] = scaleY * mat4[5] + ty * mat4[7];\r\n        mat4[6] = scaleZ * mat4[6] + tz * mat4[7];\r\n\r\n        mat4[8] = scaleX * mat4[8] + tx * mat4[11];\r\n        mat4[9] = scaleY * mat4[9] + ty * mat4[11];\r\n        mat4[10] = scaleZ * mat4[10] + tz * mat4[11];\r\n\r\n        mat4[12] = scaleX * mat4[12] + tx * mat4[15];\r\n        mat4[13] = scaleY * mat4[13] + ty * mat4[15];\r\n        mat4[14] = scaleZ * mat4[14] + tz * mat4[15];\r\n    }\r\n\r\n    // TODO: remove props\r\n    applyInverse<P extends IPointData = Point>(pos: IPointData, newPos?: P): P\r\n    {\r\n        newPos = (newPos || new Point3d()) as any;\r\n        if (!this._mat4inv)\r\n        {\r\n            this._mat4inv = new Float64Array(16);\r\n        }\r\n\r\n        const mat4 = this._mat4inv;\r\n        const a = this.mat4;\r\n        const x = pos.x;\r\n        const y = pos.y;\r\n        // TODO: pixi 6.1.0 global mixin\r\n        let z = (pos as any).z || 0;\r\n\r\n        if (!this.cacheInverse || this._updateId !== this._dirtyId)\r\n        {\r\n            this._updateId = this._dirtyId;\r\n            Matrix3d.glMatrixMat4Invert(mat4, a);\r\n        }\r\n\r\n        const w1 = 1.0 / (mat4[3] * x + mat4[7] * y + mat4[11] * z + mat4[15]);\r\n        const x1 = w1 * (mat4[0] * x + mat4[4] * y + mat4[8] * z + mat4[12]);\r\n        const y1 = w1 * (mat4[1] * x + mat4[5] * y + mat4[9] * z + mat4[13]);\r\n        const z1 = w1 * (mat4[2] * x + mat4[6] * y + mat4[10] * z + mat4[14]);\r\n\r\n        z += 1.0;\r\n\r\n        const w2 = 1.0 / (mat4[3] * x + mat4[7] * y + mat4[11] * z + mat4[15]);\r\n        const x2 = w2 * (mat4[0] * x + mat4[4] * y + mat4[8] * z + mat4[12]);\r\n        const y2 = w2 * (mat4[1] * x + mat4[5] * y + mat4[9] * z + mat4[13]);\r\n        const z2 = w2 * (mat4[2] * x + mat4[6] * y + mat4[10] * z + mat4[14]);\r\n\r\n        if (Math.abs(z1 - z2) < 1e-10)\r\n        {\r\n            (newPos as any).set(NaN, NaN, 0);\r\n        }\r\n\r\n        const alpha = (0 - z1) / (z2 - z1);\r\n\r\n        (newPos as any).set((x2 - x1) * alpha + x1, (y2 - y1) * alpha + y1, 0.0);\r\n\r\n        return newPos;\r\n    }\r\n\r\n    invert(): Matrix3d\r\n    {\r\n        Matrix3d.glMatrixMat4Invert(this.mat4, this.mat4);\r\n\r\n        return this;\r\n    }\r\n\r\n    invertCopyTo(matrix: Matrix3d): void\r\n    {\r\n        if (!this._mat4inv)\r\n        {\r\n            this._mat4inv = new Float64Array(16);\r\n        }\r\n\r\n        const mat4 = this._mat4inv;\r\n        const a = this.mat4;\r\n\r\n        if (!this.cacheInverse || this._updateId !== this._dirtyId)\r\n        {\r\n            this._updateId = this._dirtyId;\r\n            Matrix3d.glMatrixMat4Invert(mat4, a);\r\n        }\r\n\r\n        matrix.mat4.set(mat4);\r\n    }\r\n\r\n    identity(): Matrix3d\r\n    {\r\n        const mat3 = this.mat4;\r\n\r\n        mat3[0] = 1;\r\n        mat3[1] = 0;\r\n        mat3[2] = 0;\r\n        mat3[3] = 0;\r\n\r\n        mat3[4] = 0;\r\n        mat3[5] = 1;\r\n        mat3[6] = 0;\r\n        mat3[7] = 0;\r\n\r\n        mat3[8] = 0;\r\n        mat3[9] = 0;\r\n        mat3[10] = 1;\r\n        mat3[11] = 0;\r\n\r\n        mat3[12] = 0;\r\n        mat3[13] = 0;\r\n        mat3[14] = 0;\r\n        mat3[15] = 1;\r\n\r\n        return this;\r\n    }\r\n\r\n    clone(): Matrix3d\r\n    {\r\n        return new Matrix3d(this.mat4);\r\n    }\r\n\r\n    copyTo3d(matrix: Matrix3d): Matrix3d\r\n    {\r\n        const mat3 = this.mat4;\r\n        const ar2 = matrix.mat4;\r\n\r\n        ar2[0] = mat3[0];\r\n        ar2[1] = mat3[1];\r\n        ar2[2] = mat3[2];\r\n        ar2[3] = mat3[3];\r\n        ar2[4] = mat3[4];\r\n        ar2[5] = mat3[5];\r\n        ar2[6] = mat3[6];\r\n        ar2[7] = mat3[7];\r\n        ar2[8] = mat3[8];\r\n\r\n        return matrix;\r\n    }\r\n\r\n    copyTo2d(matrix: Matrix2d): Matrix2d\r\n    {\r\n        const mat3 = this.mat4;\r\n        const ar2 = matrix.mat3;\r\n\r\n        ar2[0] = mat3[0];\r\n        ar2[1] = mat3[1];\r\n        ar2[2] = mat3[3];\r\n        ar2[3] = mat3[4];\r\n        ar2[4] = mat3[5];\r\n        ar2[5] = mat3[7];\r\n        ar2[6] = mat3[12];\r\n        ar2[7] = mat3[13];\r\n        ar2[8] = mat3[15];\r\n\r\n        return matrix;\r\n    }\r\n\r\n    copyTo2dOr3d<P extends Matrix2d | Matrix3d>(matrix: P): P\r\n    {\r\n        if (matrix instanceof Matrix2d)\r\n        {\r\n            return this.copyTo2d(matrix) as any;\r\n        }\r\n\r\n        return this.copyTo3d(matrix as any) as any;\r\n    }\r\n\r\n    /**\r\n     * legacy method, change the values of given pixi matrix\r\n     * @param matrix\r\n     * @param affine\r\n     * @param preserveOrientation\r\n     * @return matrix\r\n     */\r\n    copyTo(matrix: Matrix, affine?: AFFINE, preserveOrientation?: boolean): Matrix\r\n    {\r\n        const mat3 = this.mat4;\r\n        const d = 1.0 / mat3[15];\r\n        const tx = mat3[12] * d; const\r\n            ty = mat3[13] * d;\r\n\r\n        matrix.a = (mat3[0] - mat3[3] * tx) * d;\r\n        matrix.b = (mat3[1] - mat3[3] * ty) * d;\r\n        matrix.c = (mat3[4] - mat3[7] * tx) * d;\r\n        matrix.d = (mat3[5] - mat3[7] * ty) * d;\r\n        matrix.tx = tx;\r\n        matrix.ty = ty;\r\n\r\n        if (affine >= 2)\r\n        {\r\n            let D = matrix.a * matrix.d - matrix.b * matrix.c;\r\n\r\n            if (!preserveOrientation)\r\n            {\r\n                D = Math.abs(D);\r\n            }\r\n            if (affine === AFFINE.POINT)\r\n            {\r\n                if (D > 0)\r\n                {\r\n                    D = 1;\r\n                }\r\n                else D = -1;\r\n                matrix.a = D;\r\n                matrix.b = 0;\r\n                matrix.c = 0;\r\n                matrix.d = D;\r\n            }\r\n            else if (affine === AFFINE.AXIS_X)\r\n            {\r\n                D /= Math.sqrt(matrix.b * matrix.b + matrix.d * matrix.d);\r\n                matrix.c = 0;\r\n                matrix.d = D;\r\n            }\r\n            else if (affine === AFFINE.AXIS_Y)\r\n            {\r\n                D /= Math.sqrt(matrix.a * matrix.a + matrix.c * matrix.c);\r\n                matrix.a = D;\r\n                matrix.c = 0;\r\n            }\r\n        }\r\n\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * legacy method, change the values of given pixi matrix\r\n     * @param matrix\r\n     * @return\r\n     */\r\n    copyFrom(matrix: Matrix): this\r\n    {\r\n        const mat3 = this.mat4;\r\n\r\n        mat3[0] = matrix.a;\r\n        mat3[1] = matrix.b;\r\n        mat3[2] = 0;\r\n        mat3[3] = 0;\r\n\r\n        mat3[4] = matrix.c;\r\n        mat3[5] = matrix.d;\r\n        mat3[6] = 0;\r\n        mat3[7] = 0;\r\n\r\n        mat3[8] = 0;\r\n        mat3[9] = 0;\r\n        mat3[10] = 1;\r\n        mat3[11] = 0;\r\n\r\n        mat3[12] = matrix.tx;\r\n        mat3[13] = matrix.ty;\r\n        mat3[14] = 0;\r\n        mat3[15] = 1;\r\n\r\n        this._dirtyId++;\r\n\r\n        return this;\r\n    }\r\n\r\n    setToMultLegacy(pt: Matrix, lt: Matrix3d): this\r\n    {\r\n        const out = this.mat4;\r\n        const b = lt.mat4;\r\n\r\n        const a00 = pt.a; const a01 = pt.b;\r\n        const a10 = pt.c; const a11 = pt.d;\r\n        const a30 = pt.tx; const\r\n            a31 = pt.ty;\r\n\r\n        let b0 = b[0]; let b1 = b[1]; let b2 = b[2]; let\r\n            b3 = b[3];\r\n\r\n        out[0] = b0 * a00 + b1 * a10 + b3 * a30;\r\n        out[1] = b0 * a01 + b1 * a11 + b3 * a31;\r\n        out[2] = b2;\r\n        out[3] = b3;\r\n\r\n        b0 = b[4];\r\n        b1 = b[5];\r\n        b2 = b[6];\r\n        b3 = b[7];\r\n        out[4] = b0 * a00 + b1 * a10 + b3 * a30;\r\n        out[5] = b0 * a01 + b1 * a11 + b3 * a31;\r\n        out[6] = b2;\r\n        out[7] = b3;\r\n\r\n        b0 = b[8];\r\n        b1 = b[9];\r\n        b2 = b[10];\r\n        b3 = b[11];\r\n        out[8] = b0 * a00 + b1 * a10 + b3 * a30;\r\n        out[9] = b0 * a01 + b1 * a11 + b3 * a31;\r\n        out[10] = b2;\r\n        out[11] = b3;\r\n\r\n        b0 = b[12];\r\n        b1 = b[13];\r\n        b2 = b[14];\r\n        b3 = b[15];\r\n        out[12] = b0 * a00 + b1 * a10 + b3 * a30;\r\n        out[13] = b0 * a01 + b1 * a11 + b3 * a31;\r\n        out[14] = b2;\r\n        out[15] = b3;\r\n\r\n        this._dirtyId++;\r\n\r\n        return this;\r\n    }\r\n\r\n    setToMultLegacy2(pt: Matrix3d, lt: Matrix): this\r\n    {\r\n        const out = this.mat4;\r\n        const a = pt.mat4;\r\n\r\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2]; const\r\n            a03 = a[3];\r\n        const a10 = a[4]; const a11 = a[5]; const a12 = a[6]; const\r\n            a13 = a[7];\r\n\r\n        const b00 = lt.a; const b01 = lt.b;\r\n        const b10 = lt.c; const b11 = lt.d;\r\n        const b30 = lt.tx; const\r\n            b31 = lt.ty;\r\n\r\n        out[0] = b00 * a00 + b01 * a10;\r\n        out[1] = b00 * a01 + b01 * a11;\r\n        out[2] = b00 * a02 + b01 * a12;\r\n        out[3] = b00 * a03 + b01 * a13;\r\n\r\n        out[4] = b10 * a00 + b11 * a10;\r\n        out[5] = b10 * a01 + b11 * a11;\r\n        out[6] = b10 * a02 + b11 * a12;\r\n        out[7] = b10 * a03 + b11 * a13;\r\n\r\n        out[8] = a[8];\r\n        out[9] = a[9];\r\n        out[10] = a[10];\r\n        out[11] = a[11];\r\n\r\n        out[12] = b30 * a00 + b31 * a10 + a[12];\r\n        out[13] = b30 * a01 + b31 * a11 + a[13];\r\n        out[14] = b30 * a02 + b31 * a12 + a[14];\r\n        out[15] = b30 * a03 + b31 * a13 + a[15];\r\n\r\n        this._dirtyId++;\r\n\r\n        return this;\r\n    }\r\n\r\n    // that's transform multiplication we use\r\n    setToMult(pt: Matrix3d, lt: Matrix3d): this\r\n    {\r\n        Matrix3d.glMatrixMat4Multiply(this.mat4, pt.mat4, lt.mat4);\r\n\r\n        this._dirtyId++;\r\n\r\n        return this;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    prepend(lt: any): void\r\n    {\r\n        if (lt.mat4)\r\n        {\r\n            this.setToMult(lt, this);\r\n        }\r\n        else\r\n        {\r\n            this.setToMultLegacy(lt, this);\r\n        }\r\n    }\r\n\r\n    static glMatrixMat4Invert(out: Float64Array, a: Float64Array): Float64Array\r\n    {\r\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2]; const\r\n            a03 = a[3];\r\n        const a10 = a[4]; const a11 = a[5]; const a12 = a[6]; const\r\n            a13 = a[7];\r\n        const a20 = a[8]; const a21 = a[9]; const a22 = a[10]; const\r\n            a23 = a[11];\r\n        const a30 = a[12]; const a31 = a[13]; const a32 = a[14]; const\r\n            a33 = a[15];\r\n\r\n        const b00 = a00 * a11 - a01 * a10;\r\n        const b01 = a00 * a12 - a02 * a10;\r\n        const b02 = a00 * a13 - a03 * a10;\r\n        const b03 = a01 * a12 - a02 * a11;\r\n        const b04 = a01 * a13 - a03 * a11;\r\n        const b05 = a02 * a13 - a03 * a12;\r\n        const b06 = a20 * a31 - a21 * a30;\r\n        const b07 = a20 * a32 - a22 * a30;\r\n        const b08 = a20 * a33 - a23 * a30;\r\n        const b09 = a21 * a32 - a22 * a31;\r\n        const b10 = a21 * a33 - a23 * a31;\r\n        const b11 = a22 * a33 - a23 * a32;\r\n\r\n        // Calculate the determinant\r\n        let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n        if (!det)\r\n        {\r\n            return null;\r\n        }\r\n        det = 1.0 / det;\r\n\r\n        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\r\n        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\r\n        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\r\n        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\r\n        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\r\n        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\r\n        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\r\n        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\r\n        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\r\n        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\r\n        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\r\n        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\r\n        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\r\n        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\r\n        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\r\n        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\r\n\r\n        return out;\r\n    }\r\n\r\n    static glMatrixMat4Multiply(out: Float64Array, a: Float64Array, b: Float64Array): Float64Array\r\n    {\r\n        const a00 = a[0]; const a01 = a[1]; const a02 = a[2]; const\r\n            a03 = a[3];\r\n        const a10 = a[4]; const a11 = a[5]; const a12 = a[6]; const\r\n            a13 = a[7];\r\n        const a20 = a[8]; const a21 = a[9]; const a22 = a[10]; const\r\n            a23 = a[11];\r\n        const a30 = a[12]; const a31 = a[13]; const a32 = a[14]; const\r\n            a33 = a[15];\r\n\r\n        // Cache only the current line of the second matrix\r\n        let b0 = b[0]; let b1 = b[1]; let b2 = b[2]; let\r\n            b3 = b[3];\r\n\r\n        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        b0 = b[4];\r\n        b1 = b[5];\r\n        b2 = b[6];\r\n        b3 = b[7];\r\n        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        b0 = b[8];\r\n        b1 = b[9];\r\n        b2 = b[10];\r\n        b3 = b[11];\r\n        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        b0 = b[12];\r\n        b1 = b[13];\r\n        b2 = b[14];\r\n        b3 = b[15];\r\n        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n        return out;\r\n    }\r\n}\r\n","import { LinearProjection } from '../base';\r\nimport { ObservablePoint3d } from './Point3d';\r\nimport { Matrix, Transform } from '@pixi/math';\r\nimport { Matrix3d } from './Matrix3d';\r\nimport { ObservableEuler } from './ObservableEuler';\r\n\r\nconst tempMat = new Matrix3d();\r\n\r\nexport class Projection3d extends LinearProjection<Matrix3d>\r\n{\r\n    constructor(legacy: Transform, enable?: boolean)\r\n    {\r\n        super(legacy, enable);\r\n        this.local = new Matrix3d();\r\n        this.world = new Matrix3d();\r\n\r\n        this.local.cacheInverse = true;\r\n        this.world.cacheInverse = true;\r\n\r\n        this.position._z = 0;\r\n        this.scale._z = 1;\r\n        this.pivot._z = 0;\r\n    }\r\n\r\n    cameraMatrix: Matrix3d = null;\r\n\r\n    _cameraMode = false;\r\n\r\n    get cameraMode(): boolean\r\n    {\r\n        return this._cameraMode;\r\n    }\r\n\r\n    set cameraMode(value: boolean)\r\n    {\r\n        if (this._cameraMode === value)\r\n        {\r\n            return;\r\n        }\r\n        this._cameraMode = value;\r\n\r\n        this.euler._sign = this._cameraMode ? -1 : 1;\r\n        this.euler._quatDirtyId++;\r\n\r\n        if (value)\r\n        {\r\n            this.cameraMatrix = new Matrix3d();\r\n        }\r\n    }\r\n\r\n    position = new ObservablePoint3d(this.onChange, this, 0, 0);\r\n    scale = new ObservablePoint3d(this.onChange, this, 1, 1);\r\n    euler = new ObservableEuler(this.onChange, this, 0, 0, 0);\r\n    pivot = new ObservablePoint3d(this.onChange, this, 0, 0);\r\n\r\n    onChange(): void\r\n    {\r\n        this._projID++;\r\n    }\r\n\r\n    clear(): void\r\n    {\r\n        if (this.cameraMatrix)\r\n        {\r\n            this.cameraMatrix.identity();\r\n        }\r\n        this.position.set(0, 0, 0);\r\n        this.scale.set(1, 1, 1);\r\n        this.euler.set(0, 0, 0);\r\n        this.pivot.set(0, 0, 0);\r\n        super.clear();\r\n    }\r\n\r\n    updateLocalTransform(lt: Matrix): void\r\n    {\r\n        if (this._projID === 0)\r\n        {\r\n            this.local.copyFrom(lt);\r\n\r\n            return;\r\n        }\r\n        const matrix = this.local;\r\n        const euler = this.euler;\r\n        const pos = this.position;\r\n        const scale = this.scale;\r\n        const pivot = this.pivot;\r\n\r\n        euler.update();\r\n\r\n        if (!this.cameraMode)\r\n        {\r\n            matrix.setToRotationTranslationScale(euler.quaternion, pos._x, pos._y, pos._z, scale._x, scale._y, scale._z);\r\n            matrix.translate(-pivot._x, -pivot._y, -pivot._z);\r\n            matrix.setToMultLegacy(lt, matrix);\r\n\r\n            return;\r\n        }\r\n\r\n        matrix.setToMultLegacy(lt, this.cameraMatrix);\r\n        matrix.translate(pivot._x, pivot._y, pivot._z);\r\n        matrix.scale(1.0 / scale._x, 1.0 / scale._y, 1.0 / scale._z);\r\n        tempMat.setToRotationTranslationScale(euler.quaternion, 0, 0, 0, 1, 1, 1);\r\n        matrix.setToMult(matrix, tempMat);\r\n        matrix.translate(-pos._x, -pos._y, -pos._z);\r\n\r\n        this.local._dirtyId++;\r\n    }\r\n}\r\n","/* eslint-disable no-mixed-operators */\r\nimport { Projection3d } from './Projection3d';\r\nimport { Container, DisplayObject } from '@pixi/display';\r\nimport { IPointData, Matrix, Point } from '@pixi/math';\r\nimport { TRANSFORM_STEP } from '../base';\r\nimport { IEuler } from './ObservableEuler';\r\n\r\nexport function container3dWorldTransform(): Matrix\r\n{\r\n    return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\r\n}\r\n\r\nexport interface IDisplayObject3d {\r\n    isFrontFace(forceUpdate?: boolean): boolean;\r\n    getDepth(forceUpdate?: boolean): number;\r\n    // eslint-disable-next-line max-len\r\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean, step?: TRANSFORM_STEP): P;\r\n    position3d: IPointData;\r\n    scale3d: IPointData;\r\n    euler: IEuler;\r\n    pivot3d: IPointData;\r\n}\r\n\r\nexport class Container3d extends Container implements IDisplayObject3d\r\n{\r\n    constructor()\r\n    {\r\n        super();\r\n        this.proj = new Projection3d(this.transform);\r\n    }\r\n\r\n    proj: Projection3d;\r\n\r\n    isFrontFace(forceUpdate = false): boolean\r\n    {\r\n        if (forceUpdate)\r\n        {\r\n            this._recursivePostUpdateTransform();\r\n            this.displayObjectUpdateTransform();\r\n        }\r\n\r\n        const mat = this.proj.world.mat4;\r\n        const dx1 = mat[0] * mat[15] - mat[3] * mat[12];\r\n        const dy1 = mat[1] * mat[15] - mat[3] * mat[13];\r\n        const dx2 = mat[4] * mat[15] - mat[7] * mat[12];\r\n        const dy2 = mat[5] * mat[15] - mat[7] * mat[13];\r\n\r\n        return dx1 * dy2 - dx2 * dy1 > 0;\r\n    }\r\n\r\n    /**\r\n     * returns depth from 0 to 1\r\n     *\r\n     * @param {boolean} forceUpdate whether to force matrix updates\r\n     * @returns {number} depth\r\n     */\r\n    getDepth(forceUpdate = false): number\r\n    {\r\n        if (forceUpdate)\r\n        {\r\n            this._recursivePostUpdateTransform();\r\n            this.displayObjectUpdateTransform();\r\n        }\r\n\r\n        const mat4 = this.proj.world.mat4;\r\n\r\n        return mat4[14] / mat4[15];\r\n    }\r\n\r\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean,\r\n        step = TRANSFORM_STEP.ALL): P\r\n    {\r\n        if (from)\r\n        {\r\n            position = from.toGlobal(position, point, skipUpdate);\r\n        }\r\n\r\n        if (!skipUpdate)\r\n        {\r\n            this._recursivePostUpdateTransform();\r\n        }\r\n\r\n        if (step === TRANSFORM_STEP.ALL)\r\n        {\r\n            if (!skipUpdate)\r\n            {\r\n                this.displayObjectUpdateTransform();\r\n            }\r\n            if (this.proj.affine)\r\n            {\r\n                return this.transform.worldTransform.applyInverse(position, point) as any;\r\n            }\r\n\r\n            return this.proj.world.applyInverse(position, point) as any;\r\n        }\r\n\r\n        if (this.parent)\r\n        {\r\n            point = this.parent.worldTransform.applyInverse(position, point) as any;\r\n        }\r\n        else\r\n        {\r\n            point.x = position.x;\r\n            point.y = position.y;\r\n            // TODO: pixi 6.1.0 global mixin\r\n            (point as any).z = (position as any).z;\r\n        }\r\n        if (step === TRANSFORM_STEP.NONE)\r\n        {\r\n            return point;\r\n        }\r\n\r\n        point = this.transform.localTransform.applyInverse(point, point) as any;\r\n        if (step === TRANSFORM_STEP.PROJ && this.proj.cameraMode)\r\n        {\r\n            point = this.proj.cameraMatrix.applyInverse(point, point) as any;\r\n        }\r\n\r\n        return point;\r\n    }\r\n\r\n    get worldTransform(): Matrix\r\n    {\r\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\r\n    }\r\n\r\n    get position3d(): IPointData\r\n    {\r\n        return this.proj.position;\r\n    }\r\n    set position3d(value: IPointData)\r\n    {\r\n        this.proj.position.copyFrom(value);\r\n    }\r\n    get scale3d(): IPointData\r\n    {\r\n        return this.proj.scale;\r\n    }\r\n    set scale3d(value: IPointData)\r\n    {\r\n        this.proj.scale.copyFrom(value);\r\n    }\r\n    get euler(): IEuler\r\n    {\r\n        return this.proj.euler;\r\n    }\r\n    set euler(value: IEuler)\r\n    {\r\n        this.proj.euler.copyFrom(value);\r\n    }\r\n    get pivot3d(): IPointData\r\n    {\r\n        return this.proj.pivot;\r\n    }\r\n    set pivot3d(value: IPointData)\r\n    {\r\n        this.proj.pivot.copyFrom(value);\r\n    }\r\n}\r\n\r\nexport const container3dToLocal = Container3d.prototype.toLocal;\r\nexport const container3dGetDepth = Container3d.prototype.getDepth;\r\nexport const container3dIsFrontFace = Container3d.prototype.isFrontFace;\r\n","import { Container3d } from './Container3d';\r\n\r\nexport class Camera3d extends Container3d\r\n{\r\n    constructor()\r\n    {\r\n        super();\r\n        this.proj.cameraMode = true;\r\n        this.setPlanes(400, 10, 10000, false);\r\n    }\r\n\r\n    _far = 0;\r\n    _near = 0;\r\n    _focus = 0;\r\n    _orthographic = false;\r\n\r\n    get far(): number\r\n    {\r\n        return this._far;\r\n    }\r\n\r\n    get near(): number\r\n    {\r\n        return this._near;\r\n    }\r\n\r\n    get focus(): number\r\n    {\r\n        return this._focus;\r\n    }\r\n\r\n    get ortographic(): boolean\r\n    {\r\n        return this._orthographic;\r\n    }\r\n\r\n    setPlanes(focus: number, near = 10, far = 10000, orthographic = false): void\r\n    {\r\n        this._focus = focus;\r\n        this._near = near;\r\n        this._far = far;\r\n        this._orthographic = orthographic;\r\n\r\n        const proj = this.proj;\r\n        const mat4 = proj.cameraMatrix.mat4;\r\n\r\n        proj._projID++;\r\n\r\n        mat4[10] = 1.0 / (far - near);\r\n        mat4[14] = (focus - near) / (far - near);\r\n        if (this._orthographic)\r\n        {\r\n            mat4[11] = 0;\r\n        }\r\n        else\r\n        {\r\n            mat4[11] = 1.0 / focus;\r\n        }\r\n    }\r\n}\r\n","import { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';\r\nimport { Geometry, Program, Renderer, State, Texture } from '@pixi/core';\r\nimport { Projection3d } from '../Projection3d';\r\nimport { IPointData, Matrix } from '@pixi/math';\r\nimport { DisplayObject } from '@pixi/display';\r\nimport { TRANSFORM_STEP } from '../../base';\r\nimport { container3dGetDepth, container3dIsFrontFace, container3dToLocal } from '../Container3d';\r\nimport { Euler } from '../Euler';\r\nimport { Mesh2d } from '../../proj2d';\r\n\r\nexport class Mesh3d2d extends Mesh\r\n{\r\n    constructor(geometry: Geometry, shader: MeshMaterial, state: State, drawMode?: number)\r\n    {\r\n        super(geometry, shader, state, drawMode);\r\n        this.proj = new Projection3d(this.transform);\r\n    }\r\n\r\n    vertexData2d: Float32Array = null;\r\n    proj: Projection3d;\r\n\r\n    calculateVertices(): void\r\n    {\r\n        if (this.proj._affine)\r\n        {\r\n            this.vertexData2d = null;\r\n            super.calculateVertices();\r\n\r\n            return;\r\n        }\r\n\r\n        const geometry = this.geometry as any;\r\n        const vertices = geometry.buffers[0].data;\r\n        const thisAny = this as any;\r\n\r\n        if (geometry.vertexDirtyId === thisAny.vertexDirty && thisAny._transformID === thisAny.transform._worldID)\r\n        {\r\n            return;\r\n        }\r\n\r\n        thisAny._transformID = thisAny.transform._worldID;\r\n\r\n        if (thisAny.vertexData.length !== vertices.length)\r\n        {\r\n            thisAny.vertexData = new Float32Array(vertices.length);\r\n        }\r\n        if (!this.vertexData2d || this.vertexData2d.length !== vertices.length * 3 / 2)\r\n        {\r\n            this.vertexData2d = new Float32Array(vertices.length * 3);\r\n        }\r\n\r\n        const wt = this.proj.world.mat4;\r\n\r\n        const vertexData2d = this.vertexData2d;\r\n        const vertexData = thisAny.vertexData;\r\n\r\n        for (let i = 0; i < vertexData.length / 2; i++)\r\n        {\r\n            const x = vertices[(i * 2)];\r\n            const y = vertices[(i * 2) + 1];\r\n\r\n            const xx = (wt[0] * x) + (wt[4] * y) + wt[12];\r\n            const yy = (wt[1] * x) + (wt[5] * y) + wt[13];\r\n            const ww = (wt[3] * x) + (wt[7] * y) + wt[15];\r\n\r\n            vertexData2d[i * 3] = xx;\r\n            vertexData2d[(i * 3) + 1] = yy;\r\n            vertexData2d[(i * 3) + 2] = ww;\r\n\r\n            vertexData[(i * 2)] = xx / ww;\r\n            vertexData[(i * 2) + 1] = yy / ww;\r\n        }\r\n\r\n        thisAny.vertexDirty = geometry.vertexDirtyId;\r\n    }\r\n\r\n    get worldTransform(): Matrix\r\n    {\r\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\r\n    }\r\n\r\n    toLocal<T extends IPointData>(position: IPointData, from?: DisplayObject,\r\n        point?: T, skipUpdate?: boolean,\r\n        step = TRANSFORM_STEP.ALL): T\r\n    {\r\n        return container3dToLocal.call(this, position, from, point, skipUpdate, step);\r\n    }\r\n\r\n    isFrontFace(forceUpdate?: boolean): boolean\r\n    {\r\n        return container3dIsFrontFace.call(this, forceUpdate);\r\n    }\r\n\r\n    getDepth(forceUpdate?: boolean): boolean\r\n    {\r\n        return container3dGetDepth.call(this, forceUpdate);\r\n    }\r\n\r\n    get position3d(): IPointData\r\n    {\r\n        return this.proj.position;\r\n    }\r\n    set position3d(value: IPointData)\r\n    {\r\n        this.proj.position.copyFrom(value);\r\n    }\r\n    get scale3d(): IPointData\r\n    {\r\n        return this.proj.scale;\r\n    }\r\n    set scale3d(value: IPointData)\r\n    {\r\n        this.proj.scale.copyFrom(value);\r\n    }\r\n    get euler(): Euler\r\n    {\r\n        return this.proj.euler;\r\n    }\r\n    set euler(value: Euler)\r\n    {\r\n        this.proj.euler.copyFrom(value);\r\n    }\r\n    get pivot3d(): IPointData\r\n    {\r\n        return this.proj.pivot;\r\n    }\r\n    set pivot3d(value: IPointData)\r\n    {\r\n        this.proj.pivot.copyFrom(value);\r\n    }\r\n}\r\n\r\n(Mesh3d2d.prototype as any)._renderDefault = Mesh2d.prototype._renderDefault;\r\n\r\nexport class SimpleMesh3d2d extends Mesh3d2d\r\n{\r\n    constructor(texture: Texture, vertices?: Float32Array, uvs?: Float32Array,\r\n        indices?: Uint16Array, drawMode?: number)\r\n    {\r\n        super(new MeshGeometry(vertices, uvs, indices),\r\n            new MeshMaterial(texture, {\r\n                program: Program.from(Mesh2d.defaultVertexShader, Mesh2d.defaultFragmentShader),\r\n                pluginName: 'batch2d'\r\n            }),\r\n            null,\r\n            drawMode);\r\n\r\n        (this.geometry.getBuffer('aVertexPosition') as any).static = false;\r\n    }\r\n\r\n    autoUpdate = true;\r\n\r\n    get vertices(): Float32Array\r\n    {\r\n        return this.geometry.getBuffer('aVertexPosition').data as Float32Array;\r\n    }\r\n    set vertices(value: Float32Array)\r\n    {\r\n        this.geometry.getBuffer('aVertexPosition').data = value;\r\n    }\r\n\r\n    protected _render(renderer?: Renderer): void\r\n    {\r\n        if (this.autoUpdate)\r\n        {\r\n            this.geometry.getBuffer('aVertexPosition').update();\r\n        }\r\n\r\n        (super._render as any)(renderer);\r\n    }\r\n}\r\n","import { Sprite } from '@pixi/sprite';\r\nimport { Renderer, Texture } from '@pixi/core';\r\nimport { Projection3d } from '../Projection3d';\r\nimport { IPointData, Matrix } from '@pixi/math';\r\nimport { DisplayObject } from '@pixi/display';\r\nimport { TRANSFORM_STEP } from '../../base';\r\nimport { container3dGetDepth, container3dIsFrontFace, container3dToLocal } from '../Container3d';\r\nimport { Euler } from '../Euler';\r\n/**\r\n * Same as Sprite2d, but\r\n * 1. uses Matrix3d in proj\r\n * 2. does not render if at least one vertex is behind camera\r\n */\r\nexport class Sprite3d extends Sprite\r\n{\r\n    constructor(texture: Texture)\r\n    {\r\n        super(texture);\r\n        this.proj = new Projection3d(this.transform);\r\n        this.pluginName = 'batch2d';\r\n    }\r\n\r\n    vertexData2d: Float32Array = null;\r\n    proj: Projection3d;\r\n    culledByFrustrum = false;\r\n    trimmedCulledByFrustrum = false;\r\n\r\n    calculateVertices(): void\r\n    {\r\n        const texture = this._texture;\r\n\r\n        if (this.proj._affine)\r\n        {\r\n            this.vertexData2d = null;\r\n            super.calculateVertices();\r\n\r\n            return;\r\n        }\r\n        if (!this.vertexData2d)\r\n        {\r\n            this.vertexData2d = new Float32Array(12);\r\n        }\r\n\r\n        const wid = (this.transform as any)._worldID;\r\n        const tuid = (texture as any)._updateID;\r\n        const thisAny = this as any;\r\n\r\n        if (thisAny._transformID === wid && this._textureID === tuid)\r\n        {\r\n            return;\r\n        }\r\n        // update texture UV here, because base texture can be changed without calling `_onTextureUpdate`\r\n        if (this._textureID !== tuid)\r\n        {\r\n            (this as any).uvs = (texture as any)._uvs.uvsFloat32;\r\n        }\r\n\r\n        thisAny._transformID = wid;\r\n        this._textureID = tuid;\r\n\r\n        const wt = this.proj.world.mat4;\r\n        const vertexData2d = this.vertexData2d;\r\n        const vertexData = this.vertexData;\r\n        const trim = texture.trim;\r\n        const orig = texture.orig;\r\n        const anchor = this._anchor;\r\n\r\n        let w0: number;\r\n        let w1: number;\r\n        let h0: number;\r\n        let h1: number;\r\n\r\n        if (trim)\r\n        {\r\n            w1 = trim.x - (anchor._x * orig.width);\r\n            w0 = w1 + trim.width;\r\n\r\n            h1 = trim.y - (anchor._y * orig.height);\r\n            h0 = h1 + trim.height;\r\n        }\r\n        else\r\n        {\r\n            w1 = -anchor._x * orig.width;\r\n            w0 = w1 + orig.width;\r\n\r\n            h1 = -anchor._y * orig.height;\r\n            h0 = h1 + orig.height;\r\n        }\r\n\r\n        let culled = false;\r\n\r\n        let z;\r\n\r\n        vertexData2d[0] = (wt[0] * w1) + (wt[4] * h1) + wt[12];\r\n        vertexData2d[1] = (wt[1] * w1) + (wt[5] * h1) + wt[13];\r\n        z = (wt[2] * w1) + (wt[6] * h1) + wt[14];\r\n        vertexData2d[2] = (wt[3] * w1) + (wt[7] * h1) + wt[15];\r\n        culled = culled || z < 0;\r\n\r\n        vertexData2d[3] = (wt[0] * w0) + (wt[4] * h1) + wt[12];\r\n        vertexData2d[4] = (wt[1] * w0) + (wt[5] * h1) + wt[13];\r\n        z = (wt[2] * w0) + (wt[6] * h1) + wt[14];\r\n        vertexData2d[5] = (wt[3] * w0) + (wt[7] * h1) + wt[15];\r\n        culled = culled || z < 0;\r\n\r\n        vertexData2d[6] = (wt[0] * w0) + (wt[4] * h0) + wt[12];\r\n        vertexData2d[7] = (wt[1] * w0) + (wt[5] * h0) + wt[13];\r\n        z = (wt[2] * w0) + (wt[6] * h0) + wt[14];\r\n        vertexData2d[8] = (wt[3] * w0) + (wt[7] * h0) + wt[15];\r\n        culled = culled || z < 0;\r\n\r\n        vertexData2d[9] = (wt[0] * w1) + (wt[4] * h0) + wt[12];\r\n        vertexData2d[10] = (wt[1] * w1) + (wt[5] * h0) + wt[13];\r\n        z = (wt[2] * w1) + (wt[6] * h0) + wt[14];\r\n        vertexData2d[11] = (wt[3] * w1) + (wt[7] * h0) + wt[15];\r\n        culled = culled || z < 0;\r\n\r\n        this.culledByFrustrum = culled;\r\n\r\n        vertexData[0] = vertexData2d[0] / vertexData2d[2];\r\n        vertexData[1] = vertexData2d[1] / vertexData2d[2];\r\n\r\n        vertexData[2] = vertexData2d[3] / vertexData2d[5];\r\n        vertexData[3] = vertexData2d[4] / vertexData2d[5];\r\n\r\n        vertexData[4] = vertexData2d[6] / vertexData2d[8];\r\n        vertexData[5] = vertexData2d[7] / vertexData2d[8];\r\n\r\n        vertexData[6] = vertexData2d[9] / vertexData2d[11];\r\n        vertexData[7] = vertexData2d[10] / vertexData2d[11];\r\n    }\r\n\r\n    calculateTrimmedVertices(): void\r\n    {\r\n        if (this.proj._affine)\r\n        {\r\n            super.calculateTrimmedVertices();\r\n\r\n            return;\r\n        }\r\n\r\n        const wid = (this.transform as any)._worldID;\r\n        const tuid = (this._texture as any)._updateID;\r\n        const thisAny = this as any;\r\n\r\n        if (!thisAny.vertexTrimmedData)\r\n        {\r\n            thisAny.vertexTrimmedData = new Float32Array(8);\r\n        }\r\n        else if (thisAny._transformTrimmedID === wid && this._textureTrimmedID === tuid)\r\n        {\r\n            return;\r\n        }\r\n\r\n        thisAny._transformTrimmedID = wid;\r\n        this._textureTrimmedID = tuid;\r\n\r\n        // lets do some special trim code!\r\n        const texture = this._texture;\r\n        const vertexData = thisAny.vertexTrimmedData;\r\n        const orig = texture.orig;\r\n        const anchor = this._anchor;\r\n\r\n        // lets calculate the new untrimmed bounds..\r\n        const wt = this.proj.world.mat4;\r\n\r\n        const w1 = -anchor._x * orig.width;\r\n        const w0 = w1 + orig.width;\r\n\r\n        const h1 = -anchor._y * orig.height;\r\n        const h0 = h1 + orig.height;\r\n\r\n        let culled = false;\r\n\r\n        let z;\r\n\r\n        let w = 1.0 / ((wt[3] * w1) + (wt[7] * h1) + wt[15]);\r\n\r\n        vertexData[0] = w * ((wt[0] * w1) + (wt[4] * h1) + wt[12]);\r\n        vertexData[1] = w * ((wt[1] * w1) + (wt[5] * h1) + wt[13]);\r\n        z = (wt[2] * w1) + (wt[6] * h1) + wt[14];\r\n        culled = culled || z < 0;\r\n\r\n        w = 1.0 / ((wt[3] * w0) + (wt[7] * h1) + wt[15]);\r\n        vertexData[2] = w * ((wt[0] * w0) + (wt[4] * h1) + wt[12]);\r\n        vertexData[3] = w * ((wt[1] * w0) + (wt[5] * h1) + wt[13]);\r\n        z = (wt[2] * w0) + (wt[6] * h1) + wt[14];\r\n        culled = culled || z < 0;\r\n\r\n        w = 1.0 / ((wt[3] * w0) + (wt[7] * h0) + wt[15]);\r\n        vertexData[4] = w * ((wt[0] * w0) + (wt[4] * h0) + wt[12]);\r\n        vertexData[5] = w * ((wt[1] * w0) + (wt[5] * h0) + wt[13]);\r\n        z = (wt[2] * w0) + (wt[6] * h0) + wt[14];\r\n        culled = culled || z < 0;\r\n\r\n        w = 1.0 / ((wt[3] * w1) + (wt[7] * h0) + wt[15]);\r\n        vertexData[6] = w * ((wt[0] * w1) + (wt[4] * h0) + wt[12]);\r\n        vertexData[7] = w * ((wt[1] * w1) + (wt[5] * h0) + wt[13]);\r\n        z = (wt[2] * w1) + (wt[6] * h0) + wt[14];\r\n        culled = culled || z < 0;\r\n\r\n        this.culledByFrustrum = culled;\r\n    }\r\n\r\n    _calculateBounds(): void\r\n    {\r\n        this.calculateVertices();\r\n        if (this.culledByFrustrum)\r\n        {\r\n            return;\r\n        }\r\n\r\n        const trim = this._texture.trim;\r\n        const orig = this._texture.orig;\r\n\r\n        if (!trim || (trim.width === orig.width && trim.height === orig.height))\r\n        {\r\n            // no trim! lets use the usual calculations..\r\n            this._bounds.addQuad(this.vertexData);\r\n\r\n            return;\r\n        }\r\n\r\n        this.calculateTrimmedVertices();\r\n        if (!this.trimmedCulledByFrustrum)\r\n        {\r\n            this._bounds.addQuad((this as any).vertexTrimmedData as any);\r\n        }\r\n    }\r\n\r\n    _render(renderer: Renderer): void\r\n    {\r\n        this.calculateVertices();\r\n\r\n        if (this.culledByFrustrum)\r\n        {\r\n            return;\r\n        }\r\n\r\n        renderer.batch.setObjectRenderer((renderer as any).plugins[this.pluginName]);\r\n        (renderer as any).plugins[this.pluginName].render(this);\r\n    }\r\n\r\n    containsPoint(point: IPointData): boolean\r\n    {\r\n        if (this.culledByFrustrum)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return super.containsPoint(point as any);\r\n    }\r\n\r\n    get worldTransform(): Matrix\r\n    {\r\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\r\n    }\r\n\r\n    toLocal<T extends IPointData>(position: IPointData, from?: DisplayObject,\r\n        point?: T, skipUpdate?: boolean,\r\n        step = TRANSFORM_STEP.ALL): T\r\n    {\r\n        return container3dToLocal.call(this, position, from, point, skipUpdate, step);\r\n    }\r\n\r\n    isFrontFace(forceUpdate?: boolean): boolean\r\n    {\r\n        return container3dIsFrontFace.call(this, forceUpdate);\r\n    }\r\n\r\n    getDepth(forceUpdate?: boolean): boolean\r\n    {\r\n        return container3dGetDepth.call(this, forceUpdate);\r\n    }\r\n\r\n    get position3d(): IPointData\r\n    {\r\n        return this.proj.position;\r\n    }\r\n    set position3d(value: IPointData)\r\n    {\r\n        this.proj.position.copyFrom(value);\r\n    }\r\n    get scale3d(): IPointData\r\n    {\r\n        return this.proj.scale;\r\n    }\r\n    set scale3d(value: IPointData)\r\n    {\r\n        this.proj.scale.copyFrom(value);\r\n    }\r\n    get euler(): Euler\r\n    {\r\n        return this.proj.euler;\r\n    }\r\n    set euler(value: Euler)\r\n    {\r\n        this.proj.euler.copyFrom(value);\r\n    }\r\n    get pivot3d(): IPointData\r\n    {\r\n        return this.proj.pivot;\r\n    }\r\n    set pivot3d(value: IPointData)\r\n    {\r\n        this.proj.pivot.copyFrom(value);\r\n    }\r\n}\r\n","import { Container3d, container3dWorldTransform } from '../Container3d';\r\nimport { Projection3d } from '../Projection3d';\r\nimport { Mesh3d2d } from '../mesh/Mesh3d2d';\r\nimport { MeshMaterial } from '@pixi/mesh';\r\nimport { Mesh2d } from '../../proj2d';\r\nimport { Program } from '@pixi/core';\r\nimport { SimpleMesh, SimpleRope } from '@pixi/mesh-extras';\r\nimport { Container } from '@pixi/display';\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { Sprite3d } from './Sprite3d';\r\n\r\nconst containerProps: any = {\r\n    worldTransform: {\r\n        get: container3dWorldTransform,\r\n        enumerable: true,\r\n        configurable: true\r\n    },\r\n    position3d: {\r\n        get() { return this.proj.position; },\r\n        set(value: any) { this.proj.position.copy(value); }\r\n    },\r\n    scale3d: {\r\n        get() { return this.proj.scale; },\r\n        set(value: any) { this.proj.scale.copy(value); }\r\n    },\r\n    pivot3d: {\r\n        get() { return this.proj.pivot; },\r\n        set(value: any) { this.proj.pivot.copy(value); }\r\n    },\r\n    euler: {\r\n        get() { return this.proj.euler; },\r\n        set(value: any) { this.proj.euler.copy(value); }\r\n    }\r\n};\r\n\r\nfunction convertTo3d()\r\n{\r\n    if (this.proj) return;\r\n    this.proj = new Projection3d(this.transform);\r\n    this.toLocal = Container3d.prototype.toLocal;\r\n    this.isFrontFace = Container3d.prototype.isFrontFace;\r\n    this.getDepth = Container3d.prototype.getDepth;\r\n    Object.defineProperties(this, containerProps);\r\n}\r\n\r\nContainer.prototype.convertTo3d = convertTo3d;\r\n\r\nSprite.prototype.convertTo3d = function spriteConvertTo3d()\r\n{\r\n    if (this.proj) return;\r\n    this.calculateVertices = Sprite3d.prototype.calculateVertices;\r\n    this.calculateTrimmedVertices = Sprite3d.prototype.calculateTrimmedVertices;\r\n    this._calculateBounds = Sprite3d.prototype._calculateBounds;\r\n    this.containsPoint = Sprite3d.prototype.containsPoint;\r\n    this.pluginName = 'batch2d';\r\n    convertTo3d.call(this);\r\n};\r\n\r\nContainer.prototype.convertSubtreeTo3d = function convertSubtreeTo3d()\r\n{\r\n    this.convertTo3d();\r\n    for (let i = 0; i < this.children.length; i++)\r\n    {\r\n        this.children[i].convertSubtreeTo3d();\r\n    }\r\n};\r\n\r\nSimpleMesh.prototype.convertTo3d\r\n    = SimpleRope.prototype.convertTo3d\r\n    = function meshConvert3d()\r\n        {\r\n            if (this.proj) return;\r\n            this.calculateVertices = Mesh3d2d.prototype.calculateVertices;\r\n            this._renderDefault = (Mesh3d2d.prototype as any)._renderDefault;\r\n            if (this.material.pluginName !== 'batch2d')\r\n            {\r\n                this.material = new MeshMaterial(this.material.texture, {\r\n                    program: Program.from(Mesh2d.defaultVertexShader, Mesh2d.defaultFragmentShader),\r\n                    pluginName: 'batch2d'\r\n                });\r\n            }\r\n            convertTo3d.call(this);\r\n        };\r\n","import { BatchShaderGenerator, Buffer, Geometry, Renderer, ViewableBuffer } from '@pixi/core';\r\nimport { TYPES } from '@pixi/constants';\r\nimport { premultiplyTint } from '@pixi/utils';\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { Sprite2s } from './sprites/Sprite2s';\r\nimport { Matrix } from '@pixi/math';\r\nimport { UniformBatchRenderer } from '../base';\r\n\r\nconst shaderVert = `precision highp float;\r\nattribute vec2 aVertexPosition;\r\nattribute vec3 aTrans1;\r\nattribute vec3 aTrans2;\r\nattribute vec2 aSamplerSize;\r\nattribute vec4 aFrame;\r\nattribute vec4 aColor;\r\nattribute float aTextureId;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\n\r\nvarying vec2 vertexPosition;\r\nvarying vec3 vTrans1;\r\nvarying vec3 vTrans2;\r\nvarying vec2 vSamplerSize;\r\nvarying vec4 vFrame;\r\nvarying vec4 vColor;\r\nvarying float vTextureId;\r\n\r\nvoid main(void){\r\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\r\ngl_Position.z = 0.0;\r\n\r\nvertexPosition = aVertexPosition;\r\nvTrans1 = aTrans1;\r\nvTrans2 = aTrans2;\r\nvTextureId = aTextureId;\r\nvColor = aColor;\r\nvSamplerSize = aSamplerSize;\r\nvFrame = aFrame;\r\n}\r\n`;\r\n\r\nconst shaderFrag = `precision highp float;\r\nvarying vec2 vertexPosition;\r\nvarying vec3 vTrans1;\r\nvarying vec3 vTrans2;\r\nvarying vec2 vSamplerSize;\r\nvarying vec4 vFrame;\r\nvarying vec4 vColor;\r\nvarying float vTextureId;\r\n\r\nuniform sampler2D uSamplers[%count%];\r\nuniform vec4 distortion;\r\n\r\nvoid main(void){\r\nvec2 surface;\r\nvec2 surface2;\r\n\r\nfloat vx = vertexPosition.x;\r\nfloat vy = vertexPosition.y;\r\nfloat dx = distortion.x;\r\nfloat dy = distortion.y;\r\nfloat revx = distortion.z;\r\nfloat revy = distortion.w;\r\n\r\nif (distortion.x == 0.0) {\r\nsurface.x = vx;\r\nsurface.y = vy / (1.0 + dy * vx);\r\nsurface2 = surface;\r\n} else\r\nif (distortion.y == 0.0) {\r\nsurface.y = vy;\r\nsurface.x = vx / (1.0 + dx * vy);\r\nsurface2 = surface;\r\n} else {\r\nfloat c = vy * dx - vx * dy;\r\nfloat b = (c + 1.0) * 0.5;\r\nfloat b2 = (-c + 1.0) * 0.5;\r\nfloat d = b * b + vx * dy;\r\nif (d < -0.00001) {\r\n    discard;\r\n}\r\nd = sqrt(max(d, 0.0));\r\nsurface.x = (- b + d) * revy;\r\nsurface2.x = (- b - d) * revy;\r\nsurface.y = (- b2 + d) * revx;\r\nsurface2.y = (- b2 - d) * revx;\r\n}\r\n\r\nvec2 uv;\r\nuv.x = vTrans1.x * surface.x + vTrans1.y * surface.y + vTrans1.z;\r\nuv.y = vTrans2.x * surface.x + vTrans2.y * surface.y + vTrans2.z;\r\n\r\nvec2 pixels = uv * vSamplerSize;\r\n\r\nif (pixels.x < vFrame.x || pixels.x > vFrame.z ||\r\npixels.y < vFrame.y || pixels.y > vFrame.w) {\r\nuv.x = vTrans1.x * surface2.x + vTrans1.y * surface2.y + vTrans1.z;\r\nuv.y = vTrans2.x * surface2.x + vTrans2.y * surface2.y + vTrans2.z;\r\npixels = uv * vSamplerSize;\r\n\r\nif (pixels.x < vFrame.x || pixels.x > vFrame.z ||\r\n   pixels.y < vFrame.y || pixels.y > vFrame.w) {\r\n   discard;\r\n}\r\n}\r\n\r\nvec4 edge;\r\nedge.xy = clamp(pixels - vFrame.xy + 0.5, vec2(0.0, 0.0), vec2(1.0, 1.0));\r\nedge.zw = clamp(vFrame.zw - pixels + 0.5, vec2(0.0, 0.0), vec2(1.0, 1.0));\r\n\r\nfloat alpha = 1.0; //edge.x * edge.y * edge.z * edge.w;\r\nvec4 rColor = vColor * alpha;\r\n\r\nfloat textureId = floor(vTextureId+0.5);\r\nvec2 vTextureCoord = uv;\r\nvec4 color;\r\n%forloop%\r\ngl_FragColor = color * rColor;\r\n}`;\r\n\r\nexport class BatchBilineardGeometry extends Geometry\r\n{\r\n    _buffer: Buffer;\r\n    _indexBuffer : Buffer;\r\n\r\n    constructor(_static = false)\r\n    {\r\n        super();\r\n\r\n        this._buffer = new Buffer(null, _static, false);\r\n\r\n        this._indexBuffer = new Buffer(null, _static, true);\r\n\r\n        this.addAttribute('aVertexPosition', this._buffer, 2, false, TYPES.FLOAT)\r\n            .addAttribute('aTrans1', this._buffer, 3, false, TYPES.FLOAT)\r\n            .addAttribute('aTrans2', this._buffer, 3, false, TYPES.FLOAT)\r\n            .addAttribute('aSamplerSize', this._buffer, 2, false, TYPES.FLOAT)\r\n            .addAttribute('aFrame', this._buffer, 4, false, TYPES.FLOAT)\r\n            .addAttribute('aColor', this._buffer, 4, true, TYPES.UNSIGNED_BYTE)\r\n            .addAttribute('aTextureId', this._buffer, 1, true, TYPES.FLOAT)\r\n            .addIndex(this._indexBuffer);\r\n    }\r\n}\r\n\r\nexport class BatchBilinearPluginFactory\r\n{\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    static create(options: any): any\r\n    {\r\n        const { vertex, fragment, vertexSize, geometryClass } = (Object as any).assign({\r\n            vertex: shaderVert,\r\n            fragment: shaderFrag,\r\n            geometryClass: BatchBilineardGeometry,\r\n            vertexSize: 16,\r\n        }, options);\r\n\r\n        return class BatchPlugin extends UniformBatchRenderer\r\n        {\r\n            constructor(renderer: Renderer)\r\n            {\r\n                super(renderer);\r\n\r\n                this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\r\n                this.geometryClass = geometryClass;\r\n                this.vertexSize = vertexSize;\r\n            }\r\n\r\n            defUniforms = {\r\n                translationMatrix: new Matrix(),\r\n                distortion: new Float32Array([0, 0, Infinity, Infinity])\r\n            };\r\n            size = 1000;\r\n            forceMaxTextures = 1;\r\n\r\n            getUniforms(sprite: Sprite)\r\n            {\r\n                const { proj } = sprite as Sprite2s;\r\n\r\n                if (proj.surface !== null)\r\n                {\r\n                    return proj.uniforms;\r\n                }\r\n                if (proj._activeProjection !== null)\r\n                {\r\n                    return proj._activeProjection.uniforms;\r\n                }\r\n\r\n                return this.defUniforms;\r\n            }\r\n\r\n            // eslint-disable-next-line max-len\r\n            packInterleavedGeometry(element: any, attributeBuffer: ViewableBuffer, indexBuffer: Uint16Array, aIndex: number, iIndex: number)\r\n            {\r\n                const {\r\n                    uint32View,\r\n                    float32View,\r\n                } = attributeBuffer;\r\n                const p = aIndex / this.vertexSize;\r\n                const indices = element.indices;\r\n                const vertexData = element.vertexData;\r\n                const tex = element._texture;\r\n                const frame = tex._frame;\r\n                const aTrans = element.aTrans;\r\n                const { _batchLocation, realWidth, realHeight, resolution } = element._texture.baseTexture;\r\n\r\n                const alpha = Math.min(element.worldAlpha, 1.0);\r\n\r\n                const argb = alpha < 1.0 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha)\r\n                    : element._tintRGB + (alpha * 255 << 24);\r\n\r\n                for (let i = 0; i < vertexData.length; i += 2)\r\n                {\r\n                    float32View[aIndex] = vertexData[i];\r\n                    float32View[aIndex + 1] = vertexData[i + 1];\r\n\r\n                    float32View[aIndex + 2] = aTrans.a;\r\n                    float32View[aIndex + 3] = aTrans.c;\r\n                    float32View[aIndex + 4] = aTrans.tx;\r\n                    float32View[aIndex + 5] = aTrans.b;\r\n                    float32View[aIndex + 6] = aTrans.d;\r\n                    float32View[aIndex + 7] = aTrans.ty;\r\n\r\n                    float32View[aIndex + 8] = realWidth;\r\n                    float32View[aIndex + 9] = realHeight;\r\n                    float32View[aIndex + 10] = frame.x * resolution;\r\n                    float32View[aIndex + 11] = frame.y * resolution;\r\n                    float32View[aIndex + 12] = (frame.x + frame.width) * resolution;\r\n                    float32View[aIndex + 13] = (frame.y + frame.height) * resolution;\r\n\r\n                    uint32View[aIndex + 14] = argb;\r\n                    float32View[aIndex + 15] = _batchLocation;\r\n                    aIndex += 16;\r\n                }\r\n\r\n                for (let i = 0; i < indices.length; i++)\r\n                {\r\n                    indexBuffer[iIndex++] = p + indices[i];\r\n                }\r\n            }\r\n        };\r\n    }\r\n}\r\n","import { Text, TextStyle } from '@pixi/text';\r\nimport { Projection3d } from '../Projection3d';\r\nimport { IPointData, Matrix } from '@pixi/math';\r\nimport { container3dGetDepth, container3dIsFrontFace, container3dToLocal } from '../Container3d';\r\nimport { DisplayObject } from '@pixi/display';\r\nimport { TRANSFORM_STEP } from '../../base';\r\nimport { Sprite3d } from './Sprite3d';\r\nimport { Euler } from '../Euler';\r\n\r\nexport class Text3d extends Text\r\n{\r\n    constructor(text?: string, style?: TextStyle, canvas?: HTMLCanvasElement)\r\n    {\r\n        super(text, style, canvas);\r\n        this.proj = new Projection3d(this.transform);\r\n        this.pluginName = 'batch2d';\r\n    }\r\n\r\n    proj: Projection3d;\r\n    vertexData2d: Float32Array = null;\r\n\r\n    get worldTransform(): Matrix\r\n    {\r\n        return this.proj.affine ? this.transform.worldTransform : this.proj.world as any;\r\n    }\r\n\r\n    toLocal<T extends IPointData>(position: IPointData, from?: DisplayObject,\r\n        point?: T, skipUpdate?: boolean,\r\n        step = TRANSFORM_STEP.ALL): T\r\n    {\r\n        return container3dToLocal.call(this, position, from, point, skipUpdate, step);\r\n    }\r\n\r\n    isFrontFace(forceUpdate?: boolean): boolean\r\n    {\r\n        return container3dIsFrontFace.call(this, forceUpdate);\r\n    }\r\n\r\n    getDepth(forceUpdate?: boolean): boolean\r\n    {\r\n        return container3dGetDepth.call(this, forceUpdate);\r\n    }\r\n\r\n    get position3d(): IPointData\r\n    {\r\n        return this.proj.position;\r\n    }\r\n    set position3d(value: IPointData)\r\n    {\r\n        this.proj.position.copyFrom(value);\r\n    }\r\n    get scale3d(): IPointData\r\n    {\r\n        return this.proj.scale;\r\n    }\r\n    set scale3d(value: IPointData)\r\n    {\r\n        this.proj.scale.copyFrom(value);\r\n    }\r\n    get euler(): Euler\r\n    {\r\n        return this.proj.euler;\r\n    }\r\n    set euler(value: Euler)\r\n    {\r\n        this.proj.euler.copyFrom(value);\r\n    }\r\n    get pivot3d(): IPointData\r\n    {\r\n        return this.proj.pivot;\r\n    }\r\n    set pivot3d(value: IPointData)\r\n    {\r\n        this.proj.pivot.copyFrom(value);\r\n    }\r\n}\r\n\r\nText3d.prototype.calculateVertices = Sprite3d.prototype.calculateVertices;\r\n(Text3d.prototype as any).calculateTrimmedVertices = Sprite3d.prototype.calculateTrimmedVertices;\r\n(Text3d.prototype as any)._calculateBounds = Sprite3d.prototype._calculateBounds;\r\nText3d.prototype.containsPoint = Sprite3d.prototype.containsPoint;\r\n(Text3d.prototype as any)._render = Sprite3d.prototype._render;\r\n","import { IPointData, Matrix, Point } from '@pixi/math';\r\nimport { IWorldTransform } from './ProjectionSurface';\r\nimport { Dict } from '@pixi/utils';\r\n\r\nconst p = [new Point(), new Point(), new Point(), new Point()];\r\nconst a = [0, 0, 0, 0];\r\n\r\nexport abstract class Surface implements IWorldTransform\r\n{\r\n    surfaceID = 'default';\r\n\r\n    _updateID = 0;\r\n\r\n    vertexSrc = '';\r\n    fragmentSrc = '';\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    fillUniforms(uniforms: Dict<any>): void\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    {\r\n\r\n    }\r\n\r\n    clear(): void\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n     * made for bilinear, other things will need adjustments, like test if (0) is inside\r\n     * @param {ArrayLike<number>} v\r\n     * @param out\r\n     * @param {Matrix} after\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    boundsQuad(v: ArrayLike<number>, out: any, after?: Matrix): void\r\n    {\r\n        let minX = out[0]; let\r\n            minY = out[1];\r\n        let maxX = out[0]; let\r\n            maxY = out[1];\r\n\r\n        for (let i = 2; i < 8; i += 2)\r\n        {\r\n            if (minX > out[i]) minX = out[i];\r\n            if (maxX < out[i]) maxX = out[i];\r\n            if (minY > out[i + 1]) minY = out[i + 1];\r\n            if (maxY < out[i + 1]) maxY = out[i + 1];\r\n        }\r\n\r\n        p[0].set(minX, minY);\r\n        this.apply(p[0], p[0]);\r\n        p[1].set(maxX, minY);\r\n        this.apply(p[1], p[1]);\r\n        p[2].set(maxX, maxY);\r\n        this.apply(p[2], p[2]);\r\n        p[3].set(minX, maxY);\r\n        this.apply(p[3], p[3]);\r\n\r\n        if (after)\r\n        {\r\n            after.apply(p[0], p[0]);\r\n            after.apply(p[1], p[1]);\r\n            after.apply(p[2], p[2]);\r\n            after.apply(p[3], p[3]);\r\n            out[0] = p[0].x;\r\n            out[1] = p[0].y;\r\n            out[2] = p[1].x;\r\n            out[3] = p[1].y;\r\n            out[4] = p[2].x;\r\n            out[5] = p[2].y;\r\n            out[6] = p[3].x;\r\n            out[7] = p[3].y;\r\n        }\r\n        else\r\n        {\r\n            for (let i = 1; i <= 3; i++)\r\n            {\r\n                if (p[i].y < p[0].y || (p[i].y === p[0].y && p[i].x < p[0].x))\r\n                {\r\n                    const t = p[0];\r\n\r\n                    p[0] = p[i];\r\n                    p[i] = t;\r\n                }\r\n            }\r\n\r\n            for (let i = 1; i <= 3; i++)\r\n            {\r\n                a[i] = Math.atan2(p[i].y - p[0].y, p[i].x - p[0].x);\r\n            }\r\n            for (let i = 1; i <= 3; i++)\r\n            {\r\n                for (let j = i + 1; j <= 3; j++)\r\n                {\r\n                    if (a[i] > a[j])\r\n                    {\r\n                        const t = p[i];\r\n\r\n                        p[i] = p[j];\r\n                        p[j] = t;\r\n                        const t2 = a[i];\r\n\r\n                        a[i] = a[j];\r\n                        a[j] = t2;\r\n                    }\r\n                }\r\n            }\r\n\r\n            out[0] = p[0].x;\r\n            out[1] = p[0].y;\r\n            out[2] = p[1].x;\r\n            out[3] = p[1].y;\r\n            out[4] = p[2].x;\r\n            out[5] = p[2].y;\r\n            out[6] = p[3].x;\r\n            out[7] = p[3].y;\r\n\r\n            if (((p[3].x - p[2].x) * (p[1].y - p[2].y)) - ((p[1].x - p[2].x) * (p[3].y - p[2].y)) < 0)\r\n            {\r\n                // triangle!!!\r\n                out[4] = p[3].x;\r\n                out[5] = p[3].y;\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    abstract apply(pos: IPointData, newPos: IPointData): IPointData;\r\n\r\n    // TODO: remove props\r\n    abstract applyInverse(pos: IPointData, newPos: IPointData): IPointData;\r\n}\r\n","/* eslint-disable no-mixed-operators */\r\nimport { IPoint, IPointData, Matrix, Point, Rectangle, Transform } from '@pixi/math';\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { Surface } from './BaseSurface';\r\nimport { Dict } from '@pixi/utils';\r\n\r\nconst tempMat = new Matrix();\r\nconst tempRect = new Rectangle();\r\nconst tempPoint = new Point();\r\n\r\nexport class BilinearSurface extends Surface\r\n{\r\n    distortion = new Point();\r\n\r\n    clear(): void\r\n    {\r\n        this.distortion.set(0, 0);\r\n    }\r\n\r\n    apply(pos: IPointData, newPos?: IPointData): IPointData\r\n    {\r\n        newPos = newPos || new Point();\r\n        const d = this.distortion;\r\n        const m = pos.x * pos.y;\r\n\r\n        newPos.x = pos.x + d.x * m;\r\n        newPos.y = pos.y + d.y * m;\r\n\r\n        return newPos;\r\n    }\r\n\r\n    applyInverse(pos: IPointData, newPos: IPoint): IPointData\r\n    {\r\n        newPos = newPos || new Point();\r\n        const vx = pos.x; const\r\n            vy = pos.y;\r\n        const dx = this.distortion.x; const\r\n            dy = this.distortion.y;\r\n\r\n        if (dx === 0.0)\r\n        {\r\n            newPos.x = vx;\r\n            newPos.y = vy / (1.0 + dy * vx);\r\n        }\r\n        else\r\n        if (dy === 0.0)\r\n        {\r\n            newPos.y = vy;\r\n            newPos.x = vx / (1.0 + dx * vy);\r\n        }\r\n        else\r\n        {\r\n            const b = (vy * dx - vx * dy + 1.0) * 0.5 / dy;\r\n            const d = b * b + vx / dy;\r\n\r\n            if (d <= 0.00001)\r\n            {\r\n                newPos.set(NaN, NaN);\r\n\r\n                return newPos;\r\n            }\r\n            if (dy > 0.0)\r\n            {\r\n                newPos.x = -b + Math.sqrt(d);\r\n            }\r\n            else\r\n            {\r\n                newPos.x = -b - Math.sqrt(d);\r\n            }\r\n            newPos.y = (vx / newPos.x - 1.0) / dx;\r\n        }\r\n\r\n        return newPos;\r\n    }\r\n\r\n    mapSprite(sprite: Sprite, quad: Array<IPointData>, outTransform?: Transform): this\r\n    {\r\n        const tex = sprite.texture;\r\n\r\n        tempRect.x = -sprite.anchor.x * tex.orig.width;\r\n        tempRect.y = -sprite.anchor.y * tex.orig.height;\r\n        tempRect.width = tex.orig.width;\r\n        tempRect.height = tex.orig.height;\r\n\r\n        return this.mapQuad(tempRect, quad, outTransform || sprite.transform as Transform);\r\n    }\r\n\r\n    mapQuad(rect: Rectangle, quad: Array<IPointData>, outTransform: Transform): this\r\n    {\r\n        const ax = -rect.x / rect.width;\r\n        const ay = -rect.y / rect.height;\r\n\r\n        const ax2 = (1.0 - rect.x) / rect.width;\r\n        const ay2 = (1.0 - rect.y) / rect.height;\r\n\r\n        const up1x = (quad[0].x * (1.0 - ax) + quad[1].x * ax);\r\n        const up1y = (quad[0].y * (1.0 - ax) + quad[1].y * ax);\r\n        const up2x = (quad[0].x * (1.0 - ax2) + quad[1].x * ax2);\r\n        const up2y = (quad[0].y * (1.0 - ax2) + quad[1].y * ax2);\r\n\r\n        const down1x = (quad[3].x * (1.0 - ax) + quad[2].x * ax);\r\n        const down1y = (quad[3].y * (1.0 - ax) + quad[2].y * ax);\r\n        const down2x = (quad[3].x * (1.0 - ax2) + quad[2].x * ax2);\r\n        const down2y = (quad[3].y * (1.0 - ax2) + quad[2].y * ax2);\r\n\r\n        const x00 = up1x * (1.0 - ay) + down1x * ay;\r\n        const y00 = up1y * (1.0 - ay) + down1y * ay;\r\n\r\n        const x10 = up2x * (1.0 - ay) + down2x * ay;\r\n        const y10 = up2y * (1.0 - ay) + down2y * ay;\r\n\r\n        const x01 = up1x * (1.0 - ay2) + down1x * ay2;\r\n        const y01 = up1y * (1.0 - ay2) + down1y * ay2;\r\n\r\n        const x11 = up2x * (1.0 - ay2) + down2x * ay2;\r\n        const y11 = up2y * (1.0 - ay2) + down2y * ay2;\r\n\r\n        const mat = tempMat;\r\n\r\n        mat.tx = x00;\r\n        mat.ty = y00;\r\n        mat.a = x10 - x00;\r\n        mat.b = y10 - y00;\r\n        mat.c = x01 - x00;\r\n        mat.d = y01 - y00;\r\n        tempPoint.set(x11, y11);\r\n        mat.applyInverse(tempPoint, tempPoint);\r\n        this.distortion.set(tempPoint.x - 1, tempPoint.y - 1);\r\n\r\n        outTransform.setFromMatrix(mat);\r\n\r\n        return this;\r\n    }\r\n\r\n    fillUniforms(uniforms: Dict<any>): void\r\n    {\r\n        uniforms.distortion = uniforms.distortion || new Float32Array([0, 0, 0, 0]);\r\n        const ax = Math.abs(this.distortion.x);\r\n        const ay = Math.abs(this.distortion.y);\r\n\r\n        uniforms.distortion[0] = ax * 10000 <= ay ? 0 : this.distortion.x;\r\n        uniforms.distortion[1] = ay * 10000 <= ax ? 0 : this.distortion.y;\r\n        uniforms.distortion[2] = 1.0 / uniforms.distortion[0];\r\n        uniforms.distortion[3] = 1.0 / uniforms.distortion[1];\r\n    }\r\n}\r\n","import { IPointData, Transform } from '@pixi/math';\r\nimport { AbstractProjection } from '../base';\r\nimport { Surface } from './BaseSurface';\r\nimport { BilinearSurface } from './BilinearSurface';\r\nimport { Sprite } from '@pixi/sprite';\r\n\r\nconst fun = Transform.prototype.updateTransform;\r\n\r\nexport interface IWorldTransform {\r\n    apply(pos: IPointData, newPos: IPointData): IPointData;\r\n\r\n    // TODO: remove props\r\n    applyInverse(pos: IPointData, newPos: IPointData): IPointData;\r\n}\r\n\r\nfunction transformHack(this: Transform, parentTransform: Transform): IWorldTransform\r\n{\r\n    // TODO: pixi 6.1.0 global mixin\r\n    const proj = (this as any).proj as ProjectionSurface;\r\n\r\n    const pp = (parentTransform as any).proj as ProjectionSurface;\r\n    const ta = this as any;\r\n\r\n    if (!pp)\r\n    {\r\n        fun.call(this, parentTransform);\r\n        proj._activeProjection = null;\r\n\r\n        return;\r\n    }\r\n\r\n    if (pp._surface)\r\n    {\r\n        proj._activeProjection = pp;\r\n        this.updateLocalTransform();\r\n        this.localTransform.copyTo(this.worldTransform);\r\n        if (ta._parentID < 0)\r\n        {\r\n            ++ta._worldID;\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    fun.call(this, parentTransform);\r\n    proj._activeProjection = pp._activeProjection;\r\n}\r\n\r\nexport class ProjectionSurface extends AbstractProjection\r\n{\r\n    _surface: Surface = null;\r\n    _activeProjection: ProjectionSurface = null;\r\n\r\n    // eslint-disable-next-line accessor-pairs\r\n    set enabled(value: boolean)\r\n    {\r\n        if (value === this._enabled)\r\n        {\r\n            return;\r\n        }\r\n        this._enabled = value;\r\n        if (value)\r\n        {\r\n            this.legacy.updateTransform = transformHack;\r\n            (this.legacy as any)._parentID = -1;\r\n        }\r\n        else\r\n        {\r\n            this.legacy.updateTransform = Transform.prototype.updateTransform;\r\n            (this.legacy as any)._parentID = -1;\r\n        }\r\n    }\r\n\r\n    get surface(): Surface\r\n    {\r\n        return this._surface;\r\n    }\r\n\r\n    set surface(value: Surface)\r\n    {\r\n        if (this._surface === value)\r\n        {\r\n            return;\r\n        }\r\n        this._surface = value || null;\r\n        (this.legacy as any)._parentID = -1;\r\n    }\r\n\r\n    applyPartial(pos: IPointData, newPos?: IPointData): IPointData\r\n    {\r\n        if (this._activeProjection !== null)\r\n        {\r\n            newPos = this.legacy.worldTransform.apply(pos, newPos);\r\n\r\n            return this._activeProjection.surface.apply(newPos, newPos);\r\n        }\r\n        if (this._surface !== null)\r\n        {\r\n            return this.surface.apply(pos, newPos);\r\n        }\r\n\r\n        return this.legacy.worldTransform.apply(pos, newPos);\r\n    }\r\n\r\n    apply(pos: IPointData, newPos?: IPointData): IPointData\r\n    {\r\n        if (this._activeProjection !== null)\r\n        {\r\n            newPos = this.legacy.worldTransform.apply(pos, newPos);\r\n            this._activeProjection.surface.apply(newPos, newPos);\r\n\r\n            return this._activeProjection.legacy.worldTransform.apply(newPos, newPos);\r\n        }\r\n        if (this._surface !== null)\r\n        {\r\n            newPos = this.surface.apply(pos, newPos);\r\n\r\n            return this.legacy.worldTransform.apply(newPos, newPos);\r\n        }\r\n\r\n        return this.legacy.worldTransform.apply(pos, newPos);\r\n    }\r\n\r\n    applyInverse(pos: IPointData, newPos: IPointData): IPointData\r\n    {\r\n        if (this._activeProjection !== null)\r\n        {\r\n            newPos = this._activeProjection.legacy.worldTransform.applyInverse(pos, newPos);\r\n            this._activeProjection._surface.applyInverse(newPos, newPos);\r\n\r\n            return this.legacy.worldTransform.applyInverse(newPos, newPos);\r\n        }\r\n        if (this._surface !== null)\r\n        {\r\n            newPos = this.legacy.worldTransform.applyInverse(pos, newPos);\r\n\r\n            return this._surface.applyInverse(newPos, newPos);\r\n        }\r\n\r\n        return this.legacy.worldTransform.applyInverse(pos, newPos);\r\n    }\r\n\r\n    mapBilinearSprite(sprite: Sprite, quad: Array<IPointData>): void\r\n    {\r\n        if (!(this._surface instanceof BilinearSurface))\r\n        {\r\n            this.surface = new BilinearSurface();\r\n        }\r\n        (this.surface as BilinearSurface).mapSprite(sprite, quad, this.legacy);\r\n    }\r\n\r\n    _currentSurfaceID = -1;\r\n    _currentLegacyID = -1;\r\n    _lastUniforms : any = null;\r\n\r\n    clear(): void\r\n    {\r\n        if (this.surface)\r\n        {\r\n            this.surface.clear();\r\n        }\r\n    }\r\n\r\n    get uniforms(): any\r\n    {\r\n        if (this._currentLegacyID === (this.legacy as any)._worldID\r\n            && this._currentSurfaceID === this.surface._updateID)\r\n        {\r\n            return this._lastUniforms;\r\n        }\r\n\r\n        this._lastUniforms = this._lastUniforms || {};\r\n        this._lastUniforms.translationMatrix = this.legacy.worldTransform;\r\n        this._surface.fillUniforms(this._lastUniforms);\r\n\r\n        return this._lastUniforms;\r\n    }\r\n}\r\n","import { Matrix } from '@pixi/math';\r\nimport { Texture, TextureMatrix } from '@pixi/core';\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { ProjectionSurface } from '../ProjectionSurface';\r\n\r\nexport class Sprite2s extends Sprite\r\n{\r\n    constructor(texture: Texture)\r\n    {\r\n        super(texture);\r\n        this.proj = new ProjectionSurface(this.transform);\r\n        this.pluginName = 'batch_bilinear';\r\n    }\r\n\r\n    proj: ProjectionSurface;\r\n    aTrans = new Matrix();\r\n\r\n    _calculateBounds(): void\r\n    {\r\n        this.calculateTrimmedVertices();\r\n        this._bounds.addQuad((this as any).vertexTrimmedData as any);\r\n    }\r\n\r\n    calculateVertices(): void\r\n    {\r\n        const wid = (this.transform as any)._worldID;\r\n        const tuid = (this._texture as any)._updateID;\r\n        const thisAny = this as any;\r\n\r\n        if (thisAny._transformID === wid && this._textureID === tuid)\r\n        {\r\n            return;\r\n        }\r\n\r\n        thisAny._transformID = wid;\r\n        this._textureID = tuid;\r\n\r\n        const texture = this._texture;\r\n        const vertexData = this.vertexData;\r\n        const trim = texture.trim;\r\n        const orig = texture.orig;\r\n        const anchor = this._anchor;\r\n\r\n        let w0: number;\r\n        let w1: number;\r\n        let h0: number;\r\n        let h1: number;\r\n\r\n        if (trim)\r\n        {\r\n            w1 = trim.x - (anchor._x * orig.width);\r\n            w0 = w1 + trim.width;\r\n\r\n            h1 = trim.y - (anchor._y * orig.height);\r\n            h0 = h1 + trim.height;\r\n        }\r\n        else\r\n        {\r\n            w1 = -anchor._x * orig.width;\r\n            w0 = w1 + orig.width;\r\n\r\n            h1 = -anchor._y * orig.height;\r\n            h0 = h1 + orig.height;\r\n        }\r\n\r\n        if (this.proj._surface)\r\n        {\r\n            vertexData[0] = w1;\r\n            vertexData[1] = h1;\r\n            vertexData[2] = w0;\r\n            vertexData[3] = h1;\r\n            vertexData[4] = w0;\r\n            vertexData[5] = h0;\r\n            vertexData[6] = w1;\r\n            vertexData[7] = h0;\r\n            this.proj._surface.boundsQuad(vertexData, vertexData);\r\n        }\r\n        else\r\n        {\r\n            const wt = this.transform.worldTransform;\r\n            const a = wt.a;\r\n            const b = wt.b;\r\n            const c = wt.c;\r\n            const d = wt.d;\r\n            const tx = wt.tx;\r\n            const ty = wt.ty;\r\n\r\n            vertexData[0] = (a * w1) + (c * h1) + tx;\r\n            vertexData[1] = (d * h1) + (b * w1) + ty;\r\n            vertexData[2] = (a * w0) + (c * h1) + tx;\r\n            vertexData[3] = (d * h1) + (b * w0) + ty;\r\n            vertexData[4] = (a * w0) + (c * h0) + tx;\r\n            vertexData[5] = (d * h0) + (b * w0) + ty;\r\n            vertexData[6] = (a * w1) + (c * h0) + tx;\r\n            vertexData[7] = (d * h0) + (b * w1) + ty;\r\n            if (this.proj._activeProjection)\r\n            {\r\n                this.proj._activeProjection.surface.boundsQuad(vertexData, vertexData);\r\n            }\r\n        }\r\n\r\n        if (!texture.uvMatrix)\r\n        {\r\n            texture.uvMatrix = new TextureMatrix(texture);\r\n        }\r\n        texture.uvMatrix.update();\r\n\r\n        const aTrans = this.aTrans;\r\n\r\n        aTrans.set(orig.width, 0, 0, orig.height, w1, h1);\r\n        if (this.proj._surface === null)\r\n        {\r\n            aTrans.prepend(this.transform.worldTransform);\r\n        }\r\n        aTrans.invert();\r\n        aTrans.prepend((texture.uvMatrix as any).mapCoord);\r\n    }\r\n\r\n    calculateTrimmedVertices(): void\r\n    {\r\n        const wid = (this.transform as any)._worldID;\r\n        const tuid = (this._texture as any)._updateID;\r\n        const thisAny = this as any;\r\n\r\n        if (!thisAny.vertexTrimmedData)\r\n        {\r\n            thisAny.vertexTrimmedData = new Float32Array(8);\r\n        }\r\n        else if (thisAny._transformTrimmedID === wid && this._textureTrimmedID === tuid)\r\n        {\r\n            return;\r\n        }\r\n\r\n        thisAny._transformTrimmedID = wid;\r\n        this._textureTrimmedID = tuid;\r\n\r\n        // lets do some special trim code!\r\n        const texture = this._texture;\r\n        const vertexData = thisAny.vertexTrimmedData;\r\n        const orig = texture.orig;\r\n        const anchor = this._anchor;\r\n\r\n        // lets calculate the new untrimmed bounds..\r\n\r\n        const w1 = -anchor._x * orig.width;\r\n        const w0 = w1 + orig.width;\r\n\r\n        const h1 = -anchor._y * orig.height;\r\n        const h0 = h1 + orig.height;\r\n\r\n        // TODO: take rotations into account! form temporary bounds\r\n\r\n        if (this.proj._surface)\r\n        {\r\n            vertexData[0] = w1;\r\n            vertexData[1] = h1;\r\n            vertexData[2] = w0;\r\n            vertexData[3] = h1;\r\n            vertexData[4] = w0;\r\n            vertexData[5] = h0;\r\n            vertexData[6] = w1;\r\n            vertexData[7] = h0;\r\n            this.proj._surface.boundsQuad(vertexData, vertexData, this.transform.worldTransform);\r\n        }\r\n        else\r\n        {\r\n            const wt = this.transform.worldTransform;\r\n            const a = wt.a;\r\n            const b = wt.b;\r\n            const c = wt.c;\r\n            const d = wt.d;\r\n            const tx = wt.tx;\r\n            const ty = wt.ty;\r\n\r\n            vertexData[0] = (a * w1) + (c * h1) + tx;\r\n            vertexData[1] = (d * h1) + (b * w1) + ty;\r\n            vertexData[2] = (a * w0) + (c * h1) + tx;\r\n            vertexData[3] = (d * h1) + (b * w0) + ty;\r\n            vertexData[4] = (a * w0) + (c * h0) + tx;\r\n            vertexData[5] = (d * h0) + (b * w0) + ty;\r\n            vertexData[6] = (a * w1) + (c * h0) + tx;\r\n            vertexData[7] = (d * h0) + (b * w1) + ty;\r\n            if (this.proj._activeProjection)\r\n            {\r\n                this.proj._activeProjection.surface.boundsQuad(vertexData, vertexData,\r\n                    this.proj._activeProjection.legacy.worldTransform);\r\n            }\r\n        }\r\n    }\r\n\r\n    get worldTransform(): Matrix\r\n    {\r\n        return this.proj as any;\r\n    }\r\n}\r\n","import { Sprite } from '@pixi/sprite';\r\nimport { Container } from '@pixi/display';\r\nimport { Matrix } from '@pixi/math';\r\nimport { Sprite2s } from './Sprite2s';\r\nimport { ProjectionSurface } from '../ProjectionSurface';\r\n\r\nSprite.prototype.convertTo2s = function spriteConvertTo2s()\r\n{\r\n    if (this.proj) return;\r\n    // container\r\n    this.pluginName = 'sprite_bilinear';\r\n    this.aTrans = new Matrix();\r\n    this.calculateVertices = Sprite2s.prototype.calculateVertices;\r\n    this.calculateTrimmedVertices = Sprite2s.prototype.calculateTrimmedVertices;\r\n    this._calculateBounds = Sprite2s.prototype._calculateBounds;\r\n    Container.prototype.convertTo2s.call(this);\r\n};\r\n\r\nContainer.prototype.convertTo2s = function convertTo2s()\r\n{\r\n    if (this.proj) return;\r\n    this.proj = new ProjectionSurface(this.transform);\r\n    Object.defineProperty(this, 'worldTransform', {\r\n        get()\r\n        {\r\n            return this.proj;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n};\r\n\r\nContainer.prototype.convertSubtreeTo2s = function convertSubtreeTo2s()\r\n{\r\n    this.convertTo2s();\r\n    for (let i = 0; i < this.children.length; i++)\r\n    {\r\n        this.children[i].convertSubtreeTo2s();\r\n    }\r\n};\r\n","import { Text, TextStyle } from '@pixi/text';\r\nimport { ProjectionSurface } from '../ProjectionSurface';\r\nimport { Matrix } from '@pixi/math';\r\nimport { Sprite2s } from './Sprite2s';\r\n\r\nexport class Text2s extends Text\r\n{\r\n    constructor(text?: string, style?: TextStyle, canvas?: HTMLCanvasElement)\r\n    {\r\n        super(text, style, canvas);\r\n        this.proj = new ProjectionSurface(this.transform);\r\n        this.pluginName = 'batch_bilinear';\r\n    }\r\n\r\n    proj: ProjectionSurface;\r\n\r\n    aTrans = new Matrix();\r\n\r\n    get worldTransform(): Matrix\r\n    {\r\n        return this.proj as any;\r\n    }\r\n}\r\n\r\n(Text2s.prototype as any).calculateVertices = Sprite2s.prototype.calculateVertices;\r\n(Text2s.prototype as any).calculateTrimmedVertices = Sprite2s.prototype.calculateTrimmedVertices;\r\n(Text2s.prototype as any)._calculateBounds = Sprite2s.prototype._calculateBounds;\r\n","import { Renderer } from '@pixi/core';\r\nimport { BatchBilinearPluginFactory } from './SpriteBilinearRenderer';\r\n\r\nexport * from './BaseSurface';\r\nexport * from './BilinearSurface';\r\nexport * from './ProjectionSurface';\r\nexport * from './SpriteBilinearRenderer';\r\n\r\nexport * from './sprites/convert';\r\nexport * from './sprites/Sprite2s';\r\nexport * from './sprites/Text2s';\r\n\r\nRenderer.registerPlugin('batch_bilinear', BatchBilinearPluginFactory.create({}));\r\n"],"sourceRoot":""}